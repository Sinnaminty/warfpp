/**
 * WarframeStat.us API
 * Simple API for data from the game Warframe. [Parser
 * Docs](https://wfcd.github.io/warframe-worldstate-parser/) [Items
 * Types](https://github.com/WFCD/warframe-items/blob/master/index.d.ts)
 *
 * The version of the OpenAPI document: 2.0.8
 * Contact: tobiah@protonmail.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.8.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/*
 * SearchableApi.h
 *
 *
 */

#ifndef ORG_OPENAPITOOLS_CLIENT_API_SearchableApi_H_
#define ORG_OPENAPITOOLS_CLIENT_API_SearchableApi_H_

#include "CppRestOpenAPIClient/ApiClient.h"

#include "CppRestOpenAPIClient/Object.h"
#include "CppRestOpenAPIClient/model/AcolyteI18n.h"
#include "CppRestOpenAPIClient/model/Arcane.h"
#include "CppRestOpenAPIClient/model/Conclave.h"
#include "CppRestOpenAPIClient/model/Drops.h"
#include "CppRestOpenAPIClient/model/Factions.h"
#include "CppRestOpenAPIClient/model/FissureModifiers.h"
#include "CppRestOpenAPIClient/model/GetWorldstateByPlatform_400_response.h"
#include "CppRestOpenAPIClient/model/Item.h"
#include "CppRestOpenAPIClient/model/Items.h"
#include "CppRestOpenAPIClient/model/Language.h"
#include "CppRestOpenAPIClient/model/Languages.h"
#include "CppRestOpenAPIClient/model/MissionTypes.h"
#include "CppRestOpenAPIClient/model/Mod.h"
#include "CppRestOpenAPIClient/model/OperationTypes.h"
#include "CppRestOpenAPIClient/model/SolNodeSearch.h"
#include "CppRestOpenAPIClient/model/SortieData.h"
#include "CppRestOpenAPIClient/model/Syndicates.h"
#include "CppRestOpenAPIClient/model/Tutorials.h"
#include "CppRestOpenAPIClient/model/UpgradeTypes.h"
#include "CppRestOpenAPIClient/model/Warframe.h"
#include "CppRestOpenAPIClient/model/Warframes.h"
#include "CppRestOpenAPIClient/model/Weapon.h"
#include "CppRestOpenAPIClient/model/Weapons.h"
#include <boost/optional.hpp>
#include <cpprest/details/basic_types.h>
#include <vector>

namespace org {
namespace openapitools {
namespace client {
namespace api {

using namespace org::openapitools::client::model;

class SearchableApi {
public:
  explicit SearchableApi(std::shared_ptr<const ApiClient> apiClient);

  virtual ~SearchableApi();

  /// <summary>
  /// Get Persistent Enemy translation data based on the query.
  /// </summary>
  /// <remarks>
  /// Persistent Enemy translation information for aiding translation of
  /// identifiers.
  /// </remarks>
  /// <param name="query">Keyword to search for</param>
  pplx::task<std::shared_ptr<AcolyteI18n>>
  searchAcolytesData(utility::string_t query) const;
  /// <summary>
  /// Get Arcane Enhancement Data based on the query
  /// </summary>
  /// <remarks>
  /// Available Arcane Enhancements
  /// </remarks>
  /// <param name="query">Keyword to search for</param>
  pplx::task<std::vector<std::shared_ptr<Arcane>>>
  searchArcanesData(utility::string_t query) const;
  /// <summary>
  /// Get conclave challenge data based on the query
  /// </summary>
  /// <remarks>
  /// Data about conclave challenges
  /// </remarks>
  /// <param name="query">Keyword to search for</param>
  pplx::task<std::shared_ptr<Conclave>>
  searchConclavesData(utility::string_t query) const;
  /// <summary>
  /// Get Warframe Drops data
  /// </summary>
  /// <remarks>
  /// Percentages for Warframe drops in different areas of the game
  /// </remarks>
  /// <param name="query">Keyword to search for</param>
  pplx::task<std::shared_ptr<Drops>>
  searchDropsData(utility::string_t query) const;
  /// <summary>
  /// Get Event-specific Data based on the query
  /// </summary>
  /// <remarks>
  /// Data about events
  /// </remarks>
  /// <param name="query">Keyword to search for</param>
  pplx::task<std::shared_ptr<Object>>
  searchEventsData(utility::string_t query) const;
  /// <summary>
  /// Get Faction translation information based on the query.
  /// </summary>
  /// <remarks>
  /// Strings for translating faction identifiers.
  /// </remarks>
  /// <param name="query">Keyword to search for</param>
  pplx::task<std::shared_ptr<Factions>>
  searchFactionsData(utility::string_t query) const;
  /// <summary>
  /// Get Fissure Modifier translation data based on the query.
  /// </summary>
  /// <remarks>
  /// Fissure translation identifiers
  /// </remarks>
  /// <param name="query">Keyword to search for</param>
  pplx::task<std::shared_ptr<FissureModifiers>>
  searchFissuresData(utility::string_t query) const;
  /// <summary>
  /// Get data for the closest matching single item
  /// </summary>
  /// <remarks>
  /// Item information.
  /// </remarks>
  /// <param name="query">Keyword to search for</param>
  /// <param name="language">Language to retrieve. With Caching, this has become
  /// required if you want your reply to always match your request.</param>
  /// <param name="only">Keys to keep on the object. Comma separated for
  /// multiple (optional, default to
  /// utility::conversions::to_string_t(&quot;&quot;))</param> <param
  /// name="remove">Keys to remove on the object. Comma separated for multiple
  /// (optional, default to
  /// utility::conversions::to_string_t(&quot;&quot;))</param> <param
  /// name="by">Key to search by on the object (optional, default to
  /// utility::conversions::to_string_t(&quot;&quot;))</param> <param
  /// name="acceptLanguage">Language to retrieve. Doesn&#39;t always work with
  /// caching. See Language query string parameter. (optional, default to new
  /// Language())</param>
  pplx::task<std::shared_ptr<Item>> searchItemData(
      utility::string_t query, std::shared_ptr<Language> language,
      boost::optional<utility::string_t> only,
      boost::optional<utility::string_t> remove,
      boost::optional<utility::string_t> by,
      boost::optional<std::shared_ptr<Language>> acceptLanguage) const;
  /// <summary>
  /// Get data for all matching items
  /// </summary>
  /// <remarks>
  /// Item information, such as name, unique name, type, and image name.
  /// </remarks>
  /// <param name="query">Keyword to search for</param>
  /// <param name="language">Language to retrieve. With Caching, this has become
  /// required if you want your reply to always match your request.</param>
  /// <param name="only">Keys to keep on the object. Comma separated for
  /// multiple (optional, default to
  /// utility::conversions::to_string_t(&quot;&quot;))</param> <param
  /// name="remove">Keys to remove on the object. Comma separated for multiple
  /// (optional, default to
  /// utility::conversions::to_string_t(&quot;&quot;))</param> <param
  /// name="by">Key to search by on the object (optional, default to
  /// utility::conversions::to_string_t(&quot;&quot;))</param> <param
  /// name="acceptLanguage">Language to retrieve. Doesn&#39;t always work with
  /// caching. See Language query string parameter. (optional, default to new
  /// Language())</param>
  pplx::task<std::shared_ptr<Items>> searchItemsData(
      utility::string_t query, std::shared_ptr<Language> language,
      boost::optional<utility::string_t> only,
      boost::optional<utility::string_t> remove,
      boost::optional<utility::string_t> by,
      boost::optional<std::shared_ptr<Language>> acceptLanguage) const;
  /// <summary>
  /// Get Language strings for Warframe based on the query.
  /// </summary>
  /// <remarks>
  /// Get language strings to assist translation.
  /// </remarks>
  /// <param name="query">Keyword to search for</param>
  pplx::task<std::shared_ptr<Languages>>
  searchLanguagesData(utility::string_t query) const;
  /// <summary>
  /// Get MissionType Translation Keys based on the query
  /// </summary>
  /// <remarks>
  /// Mission Type information to aid translating identifiers
  /// </remarks>
  /// <param name="query">Keyword to search for</param>
  pplx::task<std::shared_ptr<MissionTypes>>
  searchMissionTypesData(utility::string_t query) const;
  /// <summary>
  /// Get data for the closest matching single mod
  /// </summary>
  /// <remarks>
  /// Mod information.
  /// </remarks>
  /// <param name="query">Keyword to search for</param>
  /// <param name="language">Language to retrieve. With Caching, this has become
  /// required if you want your reply to always match your request.</param>
  /// <param name="only">Keys to keep on the object. Comma separated for
  /// multiple (optional, default to
  /// utility::conversions::to_string_t(&quot;&quot;))</param> <param
  /// name="remove">Keys to remove on the object. Comma separated for multiple
  /// (optional, default to
  /// utility::conversions::to_string_t(&quot;&quot;))</param> <param
  /// name="by">Key to search by on the object (optional, default to
  /// utility::conversions::to_string_t(&quot;&quot;))</param> <param
  /// name="acceptLanguage">Language to retrieve. Doesn&#39;t always work with
  /// caching. See Language query string parameter. (optional, default to new
  /// Language())</param>
  pplx::task<std::shared_ptr<Mod>> searchModData(
      utility::string_t query, std::shared_ptr<Language> language,
      boost::optional<utility::string_t> only,
      boost::optional<utility::string_t> remove,
      boost::optional<utility::string_t> by,
      boost::optional<std::shared_ptr<Language>> acceptLanguage) const;
  /// <summary>
  /// Get data for all matching mods
  /// </summary>
  /// <remarks>
  /// Mod information, such as name, unique name, type, and image name.
  /// </remarks>
  /// <param name="query">Keyword to search for</param>
  /// <param name="language">Language to retrieve. With Caching, this has become
  /// required if you want your reply to always match your request.</param>
  /// <param name="only">Keys to keep on the object. Comma separated for
  /// multiple (optional, default to
  /// utility::conversions::to_string_t(&quot;&quot;))</param> <param
  /// name="remove">Keys to remove on the object. Comma separated for multiple
  /// (optional, default to
  /// utility::conversions::to_string_t(&quot;&quot;))</param> <param
  /// name="by">Key to search by on the object (optional, default to
  /// utility::conversions::to_string_t(&quot;&quot;))</param> <param
  /// name="acceptLanguage">Language to retrieve. Doesn&#39;t always work with
  /// caching. See Language query string parameter. (optional, default to new
  /// Language())</param>
  pplx::task<std::vector<std::shared_ptr<Mod>>> searchModsData(
      utility::string_t query, std::shared_ptr<Language> language,
      boost::optional<utility::string_t> only,
      boost::optional<utility::string_t> remove,
      boost::optional<utility::string_t> by,
      boost::optional<std::shared_ptr<Language>> acceptLanguage) const;
  /// <summary>
  /// Get Sol Node information and translation data based on the query.
  /// </summary>
  /// <remarks>
  /// Sol Node translation information for aiding the translation of
  /// identifiers.
  /// </remarks>
  /// <param name="query">Keyword to search for</param>
  pplx::task<std::shared_ptr<SolNodeSearch>>
  searchNodesData(utility::string_t query) const;
  /// <summary>
  /// Get operation types data based on the query.
  /// </summary>
  /// <remarks>
  /// Operation Types information to aid translating identifiers for global
  /// upgrades
  /// </remarks>
  /// <param name="query">Keyword to search for</param>
  pplx::task<std::shared_ptr<OperationTypes>>
  searchOperationsData(utility::string_t query) const;
  /// <summary>
  /// Get Sortie translation information based on the query.
  /// </summary>
  /// <remarks>
  /// Sortie translation information for assisting translation of identifiers.
  /// </remarks>
  /// <param name="query">Keyword to search for</param>
  pplx::task<std::shared_ptr<SortieData>>
  searchSortiesData(utility::string_t query) const;
  /// <summary>
  /// Get Syndicate translation data based on the query.
  /// </summary>
  /// <remarks>
  /// Information to assist translating syndicate identifiers.
  /// </remarks>
  /// <param name="query">Keyword to search for</param>
  pplx::task<std::shared_ptr<Syndicates>>
  searchSyndicatesData(utility::string_t query) const;
  /// <summary>
  /// Get Tutorials Data based on the query
  /// </summary>
  /// <remarks>
  /// Tutorials data from DE
  /// </remarks>
  /// <param name="query">Keyword to search for</param>
  pplx::task<std::shared_ptr<Tutorials>>
  searchTutorialsData(utility::string_t query) const;
  /// <summary>
  /// Get upgrade types data for global upgrades based on the query.
  /// </summary>
  /// <remarks>
  /// Upgrade types for what can be changed by global modifiers, such as double
  /// credit weekends.
  /// </remarks>
  /// <param name="query">Keyword to search for</param>
  pplx::task<std::shared_ptr<UpgradeTypes>>
  searchUpgradeTypesData(utility::string_t query) const;
  /// <summary>
  /// Get data for the closest matching single item
  /// </summary>
  /// <remarks>
  /// Mod information.
  /// </remarks>
  /// <param name="query">Keyword to search for</param>
  /// <param name="language">Language to retrieve. With Caching, this has become
  /// required if you want your reply to always match your request.</param>
  /// <param name="only">Keys to keep on the object. Comma separated for
  /// multiple (optional, default to
  /// utility::conversions::to_string_t(&quot;&quot;))</param> <param
  /// name="remove">Keys to remove on the object. Comma separated for multiple
  /// (optional, default to
  /// utility::conversions::to_string_t(&quot;&quot;))</param> <param
  /// name="by">Key to search by on the object (optional, default to
  /// utility::conversions::to_string_t(&quot;&quot;))</param> <param
  /// name="acceptLanguage">Language to retrieve. Doesn&#39;t always work with
  /// caching. See Language query string parameter. (optional, default to new
  /// Language())</param>
  pplx::task<std::shared_ptr<Warframe>> searchWarframeData(
      utility::string_t query, std::shared_ptr<Language> language,
      boost::optional<utility::string_t> only,
      boost::optional<utility::string_t> remove,
      boost::optional<utility::string_t> by,
      boost::optional<std::shared_ptr<Language>> acceptLanguage) const;
  /// <summary>
  /// Get data for all matching Warframes
  /// </summary>
  /// <remarks>
  /// Warframe stats and general information.
  /// </remarks>
  /// <param name="query">Keyword to search for</param>
  /// <param name="language">Language to retrieve. With Caching, this has become
  /// required if you want your reply to always match your request.</param>
  /// <param name="only">Keys to keep on the object. Comma separated for
  /// multiple (optional, default to
  /// utility::conversions::to_string_t(&quot;&quot;))</param> <param
  /// name="remove">Keys to remove on the object. Comma separated for multiple
  /// (optional, default to
  /// utility::conversions::to_string_t(&quot;&quot;))</param> <param
  /// name="by">Key to search by on the object (optional, default to
  /// utility::conversions::to_string_t(&quot;&quot;))</param> <param
  /// name="acceptLanguage">Language to retrieve. Doesn&#39;t always work with
  /// caching. See Language query string parameter. (optional, default to new
  /// Language())</param>
  pplx::task<std::shared_ptr<Warframes>> searchWarframesData(
      utility::string_t query, std::shared_ptr<Language> language,
      boost::optional<utility::string_t> only,
      boost::optional<utility::string_t> remove,
      boost::optional<utility::string_t> by,
      boost::optional<std::shared_ptr<Language>> acceptLanguage) const;
  /// <summary>
  /// Get data for the closest matching single weapon
  /// </summary>
  /// <remarks>
  /// Mod information.
  /// </remarks>
  /// <param name="query">Keyword to search for</param>
  /// <param name="language">Language to retrieve. With Caching, this has become
  /// required if you want your reply to always match your request.</param>
  /// <param name="only">Keys to keep on the object. Comma separated for
  /// multiple (optional, default to
  /// utility::conversions::to_string_t(&quot;&quot;))</param> <param
  /// name="remove">Keys to remove on the object. Comma separated for multiple
  /// (optional, default to
  /// utility::conversions::to_string_t(&quot;&quot;))</param> <param
  /// name="by">Key to search by on the object (optional, default to
  /// utility::conversions::to_string_t(&quot;&quot;))</param> <param
  /// name="acceptLanguage">Language to retrieve. Doesn&#39;t always work with
  /// caching. See Language query string parameter. (optional, default to new
  /// Language())</param>
  pplx::task<std::shared_ptr<Weapon>> searchWeaponData(
      utility::string_t query, std::shared_ptr<Language> language,
      boost::optional<utility::string_t> only,
      boost::optional<utility::string_t> remove,
      boost::optional<utility::string_t> by,
      boost::optional<std::shared_ptr<Language>> acceptLanguage) const;
  /// <summary>
  /// Get data for all matching weapons
  /// </summary>
  /// <remarks>
  /// Weapon statistics.
  /// </remarks>
  /// <param name="query">Keyword to search for</param>
  /// <param name="language">Language to retrieve. With Caching, this has become
  /// required if you want your reply to always match your request.</param>
  /// <param name="only">Keys to keep on the object. Comma separated for
  /// multiple (optional, default to
  /// utility::conversions::to_string_t(&quot;&quot;))</param> <param
  /// name="remove">Keys to remove on the object. Comma separated for multiple
  /// (optional, default to
  /// utility::conversions::to_string_t(&quot;&quot;))</param> <param
  /// name="by">Key to search by on the object (optional, default to
  /// utility::conversions::to_string_t(&quot;&quot;))</param> <param
  /// name="acceptLanguage">Language to retrieve. Doesn&#39;t always work with
  /// caching. See Language query string parameter. (optional, default to new
  /// Language())</param>
  pplx::task<std::shared_ptr<Weapons>> searchWeaponsData(
      utility::string_t query, std::shared_ptr<Language> language,
      boost::optional<utility::string_t> only,
      boost::optional<utility::string_t> remove,
      boost::optional<utility::string_t> by,
      boost::optional<std::shared_ptr<Language>> acceptLanguage) const;

protected:
  std::shared_ptr<const ApiClient> m_ApiClient;
};

} // namespace api
} // namespace client
} // namespace openapitools
} // namespace org

#endif /* ORG_OPENAPITOOLS_CLIENT_API_SearchableApi_H_ */
