/**
 * WarframeStat.us API
 * Simple API for data from the game Warframe. [Parser
 * Docs](https://wfcd.github.io/warframe-worldstate-parser/) [Items
 * Types](https://github.com/WFCD/warframe-items/blob/master/index.d.ts)
 *
 * The version of the OpenAPI document: 2.0.8
 * Contact: tobiah@protonmail.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.8.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/*
 * Alert_mission.h
 *
 *
 */

#ifndef ORG_OPENAPITOOLS_CLIENT_MODEL_Alert_mission_H_
#define ORG_OPENAPITOOLS_CLIENT_MODEL_Alert_mission_H_

#include "CppRestOpenAPIClient/ModelBase.h"

#include "CppRestOpenAPIClient/model/Faction.h"
#include "CppRestOpenAPIClient/model/MissionType.h"
#include "CppRestOpenAPIClient/model/Reward.h"
#include <cpprest/details/basic_types.h>
#include <vector>

namespace org {
namespace openapitools {
namespace client {
namespace model {

class Reward;

/// <summary>
///
/// </summary>
class Alert_mission : public ModelBase {
public:
  Alert_mission();
  virtual ~Alert_mission();

  /////////////////////////////////////////////
  /// ModelBase overrides

  void validate() override;

  web::json::value toJson() const override;
  bool fromJson(const web::json::value &json) override;

  void toMultipart(std::shared_ptr<MultipartFormData> multipart,
                   const utility::string_t &namePrefix) const override;
  bool fromMultiPart(std::shared_ptr<MultipartFormData> multipart,
                     const utility::string_t &namePrefix) override;

  /////////////////////////////////////////////
  /// Alert_mission members

  /// <summary>
  ///
  /// </summary>
  std::shared_ptr<Reward> getReward() const;
  bool rewardIsSet() const;
  void unsetReward();

  void setReward(const std::shared_ptr<Reward> &value);

  /// <summary>
  ///
  /// </summary>
  utility::string_t getNode() const;
  bool nodeIsSet() const;
  void unsetNode();

  void setNode(const utility::string_t &value);

  /// <summary>
  /// Unlocalized node
  /// </summary>
  utility::string_t getNodeKey() const;
  bool nodeKeyIsSet() const;
  void unsetNodeKey();

  void setNodeKey(const utility::string_t &value);

  /// <summary>
  ///
  /// </summary>
  std::shared_ptr<Faction> getFaction() const;
  bool factionIsSet() const;
  void unsetFaction();

  void setFaction(const std::shared_ptr<Faction> &value);

  /// <summary>
  ///
  /// </summary>
  std::shared_ptr<Faction> getFactionKey() const;
  bool factionKeyIsSet() const;
  void unsetFactionKey();

  void setFactionKey(const std::shared_ptr<Faction> &value);

  /// <summary>
  ///
  /// </summary>
  double getMaxEnemyLevel() const;
  bool maxEnemyLevelIsSet() const;
  void unsetMaxEnemyLevel();

  void setMaxEnemyLevel(double value);

  /// <summary>
  ///
  /// </summary>
  double getMinEnemyLevel() const;
  bool minEnemyLevelIsSet() const;
  void unsetMinEnemyLevel();

  void setMinEnemyLevel(double value);

  /// <summary>
  ///
  /// </summary>
  double getMaxWaveNum() const;
  bool maxWaveNumIsSet() const;
  void unsetMaxWaveNum();

  void setMaxWaveNum(double value);

  /// <summary>
  ///
  /// </summary>
  std::shared_ptr<MissionType> getType() const;
  bool typeIsSet() const;
  void unsetType();

  void setType(const std::shared_ptr<MissionType> &value);

  /// <summary>
  ///
  /// </summary>
  std::shared_ptr<MissionType> getTypeKey() const;
  bool typeKeyIsSet() const;
  void unsetTypeKey();

  void setTypeKey(const std::shared_ptr<MissionType> &value);

  /// <summary>
  ///
  /// </summary>
  bool isNightmare() const;
  bool nightmareIsSet() const;
  void unsetNightmare();

  void setNightmare(bool value);

  /// <summary>
  /// Whether an Archwing is required for participating in the mision.
  /// </summary>
  bool isArchwingRequired() const;
  bool archwingRequiredIsSet() const;
  void unsetArchwingRequired();

  void setArchwingRequired(bool value);

  /// <summary>
  /// Whether the mission takes place in a submerssible mission.
  /// </summary>
  bool isIsSharkwing() const;
  bool isSharkwingIsSet() const;
  void unsetIsSharkwing();

  void setIsSharkwing(bool value);

  /// <summary>
  /// Enemy specification for the mission
  /// </summary>
  utility::string_t getEnemySpec() const;
  bool enemySpecIsSet() const;
  void unsetEnemySpec();

  void setEnemySpec(const utility::string_t &value);

  /// <summary>
  /// Override for the map on this mission
  /// </summary>
  utility::string_t getLevelOverride() const;
  bool levelOverrideIsSet() const;
  void unsetLevelOverride();

  void setLevelOverride(const utility::string_t &value);

  /// <summary>
  /// Array of strings denoting extra spawners for a mission
  /// </summary>
  std::vector<utility::string_t> &getAdvancedSpawners();
  bool advancedSpawnersIsSet() const;
  void unsetAdvancedSpawners();

  void setAdvancedSpawners(const std::vector<utility::string_t> &value);

  /// <summary>
  /// Items required to enter the mission
  /// </summary>
  std::vector<utility::string_t> &getRequiredItems();
  bool requiredItemsIsSet() const;
  void unsetRequiredItems();

  void setRequiredItems(const std::vector<utility::string_t> &value);

  /// <summary>
  /// Whether the required items are consumed
  /// </summary>
  bool isConsumeRequiredItems() const;
  bool consumeRequiredItemsIsSet() const;
  void unsetConsumeRequiredItems();

  void setConsumeRequiredItems(bool value);

  /// <summary>
  /// Whether leaders are always allowed
  /// </summary>
  bool isLeadersAlwaysAllowed() const;
  bool leadersAlwaysAllowedIsSet() const;
  void unsetLeadersAlwaysAllowed();

  void setLeadersAlwaysAllowed(bool value);

  /// <summary>
  /// Affectors for this mission
  /// </summary>
  std::vector<utility::string_t> &getLevelAuras();
  bool levelAurasIsSet() const;
  void unsetLevelAuras();

  void setLevelAuras(const std::vector<utility::string_t> &value);

  /// <summary>
  /// Description of the mission
  /// </summary>
  utility::string_t getDescription() const;
  bool descriptionIsSet() const;
  void unsetDescription();

  void setDescription(const utility::string_t &value);

protected:
  std::shared_ptr<Reward> m_Reward;
  bool m_RewardIsSet;
  utility::string_t m_Node;
  bool m_NodeIsSet;
  utility::string_t m_NodeKey;
  bool m_NodeKeyIsSet;
  std::shared_ptr<Faction> m_Faction;
  bool m_FactionIsSet;
  std::shared_ptr<Faction> m_FactionKey;
  bool m_FactionKeyIsSet;
  double m_MaxEnemyLevel;
  bool m_MaxEnemyLevelIsSet;
  double m_MinEnemyLevel;
  bool m_MinEnemyLevelIsSet;
  double m_MaxWaveNum;
  bool m_MaxWaveNumIsSet;
  std::shared_ptr<MissionType> m_Type;
  bool m_TypeIsSet;
  std::shared_ptr<MissionType> m_TypeKey;
  bool m_TypeKeyIsSet;
  bool m_Nightmare;
  bool m_NightmareIsSet;
  bool m_ArchwingRequired;
  bool m_ArchwingRequiredIsSet;
  bool m_IsSharkwing;
  bool m_IsSharkwingIsSet;
  utility::string_t m_EnemySpec;
  bool m_EnemySpecIsSet;
  utility::string_t m_LevelOverride;
  bool m_LevelOverrideIsSet;
  std::vector<utility::string_t> m_AdvancedSpawners;
  bool m_AdvancedSpawnersIsSet;
  std::vector<utility::string_t> m_RequiredItems;
  bool m_RequiredItemsIsSet;
  bool m_ConsumeRequiredItems;
  bool m_ConsumeRequiredItemsIsSet;
  bool m_LeadersAlwaysAllowed;
  bool m_LeadersAlwaysAllowedIsSet;
  std::vector<utility::string_t> m_LevelAuras;
  bool m_LevelAurasIsSet;
  utility::string_t m_Description;
  bool m_DescriptionIsSet;
};

} // namespace model
} // namespace client
} // namespace openapitools
} // namespace org

#endif /* ORG_OPENAPITOOLS_CLIENT_MODEL_Alert_mission_H_ */
