/**
 * WarframeStat.us API
 * Simple API for data from the game Warframe. [Parser
 * Docs](https://wfcd.github.io/warframe-worldstate-parser/) [Items
 * Types](https://github.com/WFCD/warframe-items/blob/master/index.d.ts)
 *
 * The version of the OpenAPI document: 2.0.8
 * Contact: tobiah@protonmail.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.8.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "CppRestOpenAPIClient/api/WarframeItemsApi.h"
#include "CppRestOpenAPIClient/IHttpBody.h"
#include "CppRestOpenAPIClient/JsonBody.h"
#include "CppRestOpenAPIClient/MultipartFormData.h"

#include <boost/algorithm/string/replace.hpp>

#include <unordered_set>

namespace org {
namespace openapitools {
namespace client {
namespace api {

using namespace org::openapitools::client::model;

WarframeItemsApi::WarframeItemsApi(std::shared_ptr<const ApiClient> apiClient)
    : m_ApiClient(apiClient) {}

WarframeItemsApi::~WarframeItemsApi() {}

pplx::task<std::shared_ptr<Items>> WarframeItemsApi::getItemsData(
    std::shared_ptr<Language> language, boost::optional<utility::string_t> only,
    boost::optional<utility::string_t> remove,
    boost::optional<std::shared_ptr<Language>> acceptLanguage) const {

  // verify the required parameter 'language' is set
  if (language == nullptr) {
    throw ApiException(400, utility::conversions::to_string_t(
                                "Missing required parameter 'language' when "
                                "calling WarframeItemsApi->getItemsData"));
  }

  std::shared_ptr<const ApiConfiguration> localVarApiConfiguration(
      m_ApiClient->getConfiguration());
  utility::string_t localVarPath = utility::conversions::to_string_t("/items");

  std::map<utility::string_t, utility::string_t> localVarQueryParams;
  std::map<utility::string_t, utility::string_t> localVarHeaderParams(
      localVarApiConfiguration->getDefaultHeaders());
  std::map<utility::string_t, utility::string_t> localVarFormParams;
  std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

  std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;
  localVarResponseHttpContentTypes.insert(
      utility::conversions::to_string_t("application/json"));

  utility::string_t localVarResponseHttpContentType;

  // use JSON if possible
  if (localVarResponseHttpContentTypes.size() == 0) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // JSON
  else if (localVarResponseHttpContentTypes.find(
               utility::conversions::to_string_t("application/json")) !=
           localVarResponseHttpContentTypes.end()) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // multipart formdata
  else if (localVarResponseHttpContentTypes.find(
               utility::conversions::to_string_t("multipart/form-data")) !=
           localVarResponseHttpContentTypes.end()) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("multipart/form-data");
  } else {
    throw ApiException(400, utility::conversions::to_string_t(
                                "WarframeItemsApi->getItemsData does not "
                                "produce any supported media type"));
  }

  localVarHeaderParams[utility::conversions::to_string_t("Accept")] =
      localVarResponseHttpContentType;

  std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;

  if (language != nullptr) {
    localVarQueryParams[utility::conversions::to_string_t("language")] =
        ApiClient::parameterToString(language);
  }
  if (only) {
    localVarQueryParams[utility::conversions::to_string_t("only")] =
        ApiClient::parameterToString(*only);
  }
  if (remove) {
    localVarQueryParams[utility::conversions::to_string_t("remove")] =
        ApiClient::parameterToString(*remove);
  }
  if (acceptLanguage && *acceptLanguage != nullptr) {
    localVarHeaderParams[utility::conversions::to_string_t("Accept-Language")] =
        ApiClient::parameterToString(*acceptLanguage);
  }

  std::shared_ptr<IHttpBody> localVarHttpBody;
  utility::string_t localVarRequestHttpContentType;

  // use JSON if possible
  if (localVarConsumeHttpContentTypes.size() == 0 ||
      localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t(
          "application/json")) != localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // multipart formdata
  else if (localVarConsumeHttpContentTypes.find(
               utility::conversions::to_string_t("multipart/form-data")) !=
           localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("multipart/form-data");
  } else if (localVarConsumeHttpContentTypes.find(
                 utility::conversions::to_string_t(
                     "application/x-www-form-urlencoded")) !=
             localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("application/x-www-form-urlencoded");
  } else {
    throw ApiException(415, utility::conversions::to_string_t(
                                "WarframeItemsApi->getItemsData does not "
                                "consume any supported media type"));
  }

  return m_ApiClient
      ->callApi(localVarPath, utility::conversions::to_string_t("GET"),
                localVarQueryParams, localVarHttpBody, localVarHeaderParams,
                localVarFormParams, localVarFileParams,
                localVarRequestHttpContentType)
      .then([=, this](web::http::http_response localVarResponse) {
        if (m_ApiClient->getResponseHandler()) {
          m_ApiClient->getResponseHandler()(localVarResponse.status_code(),
                                            localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400) {
          throw ApiException(
              localVarResponse.status_code(),
              utility::conversions::to_string_t(
                  "error calling getItemsData: ") +
                  localVarResponse.reason_phrase(),
              std::make_shared<std::stringstream>(
                  localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if (localVarResponse.headers().has(
                utility::conversions::to_string_t("Content-Type"))) {
          utility::string_t localVarContentType =
              localVarResponse
                  .headers()[utility::conversions::to_string_t("Content-Type")];
          if (localVarContentType.find(localVarResponseHttpContentType) ==
              std::string::npos) {
            throw ApiException(
                500,
                utility::conversions::to_string_t(
                    "error calling getItemsData: unexpected response type: ") +
                    localVarContentType,
                std::make_shared<std::stringstream>(
                    localVarResponse.extract_utf8string(true).get()));
          }
        }

        return localVarResponse.extract_string();
      })
      .then([=, this](utility::string_t localVarResponse) {
        std::shared_ptr<Items> localVarResult(new Items());

        if (localVarResponseHttpContentType ==
            utility::conversions::to_string_t("application/json")) {
          web::json::value localVarJson =
              web::json::value::parse(localVarResponse);

          ModelBase::fromJson(localVarJson, localVarResult);
        }
        // else if(localVarResponseHttpContentType ==
        // utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else {
          throw ApiException(
              500,
              utility::conversions::to_string_t(
                  "error calling getItemsData: unsupported response type"));
        }

        return localVarResult;
      });
}
pplx::task<std::vector<std::shared_ptr<Mod>>> WarframeItemsApi::getModsData(
    std::shared_ptr<Language> language, boost::optional<utility::string_t> only,
    boost::optional<utility::string_t> remove,
    boost::optional<std::shared_ptr<Language>> acceptLanguage) const {

  // verify the required parameter 'language' is set
  if (language == nullptr) {
    throw ApiException(400, utility::conversions::to_string_t(
                                "Missing required parameter 'language' when "
                                "calling WarframeItemsApi->getModsData"));
  }

  std::shared_ptr<const ApiConfiguration> localVarApiConfiguration(
      m_ApiClient->getConfiguration());
  utility::string_t localVarPath = utility::conversions::to_string_t("/mods");

  std::map<utility::string_t, utility::string_t> localVarQueryParams;
  std::map<utility::string_t, utility::string_t> localVarHeaderParams(
      localVarApiConfiguration->getDefaultHeaders());
  std::map<utility::string_t, utility::string_t> localVarFormParams;
  std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

  std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;
  localVarResponseHttpContentTypes.insert(
      utility::conversions::to_string_t("application/json"));

  utility::string_t localVarResponseHttpContentType;

  // use JSON if possible
  if (localVarResponseHttpContentTypes.size() == 0) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // JSON
  else if (localVarResponseHttpContentTypes.find(
               utility::conversions::to_string_t("application/json")) !=
           localVarResponseHttpContentTypes.end()) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // multipart formdata
  else if (localVarResponseHttpContentTypes.find(
               utility::conversions::to_string_t("multipart/form-data")) !=
           localVarResponseHttpContentTypes.end()) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("multipart/form-data");
  } else {
    throw ApiException(400, utility::conversions::to_string_t(
                                "WarframeItemsApi->getModsData does not "
                                "produce any supported media type"));
  }

  localVarHeaderParams[utility::conversions::to_string_t("Accept")] =
      localVarResponseHttpContentType;

  std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;

  if (language != nullptr) {
    localVarQueryParams[utility::conversions::to_string_t("language")] =
        ApiClient::parameterToString(language);
  }
  if (only) {
    localVarQueryParams[utility::conversions::to_string_t("only")] =
        ApiClient::parameterToString(*only);
  }
  if (remove) {
    localVarQueryParams[utility::conversions::to_string_t("remove")] =
        ApiClient::parameterToString(*remove);
  }
  if (acceptLanguage && *acceptLanguage != nullptr) {
    localVarHeaderParams[utility::conversions::to_string_t("Accept-Language")] =
        ApiClient::parameterToString(*acceptLanguage);
  }

  std::shared_ptr<IHttpBody> localVarHttpBody;
  utility::string_t localVarRequestHttpContentType;

  // use JSON if possible
  if (localVarConsumeHttpContentTypes.size() == 0 ||
      localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t(
          "application/json")) != localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // multipart formdata
  else if (localVarConsumeHttpContentTypes.find(
               utility::conversions::to_string_t("multipart/form-data")) !=
           localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("multipart/form-data");
  } else if (localVarConsumeHttpContentTypes.find(
                 utility::conversions::to_string_t(
                     "application/x-www-form-urlencoded")) !=
             localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("application/x-www-form-urlencoded");
  } else {
    throw ApiException(415, utility::conversions::to_string_t(
                                "WarframeItemsApi->getModsData does not "
                                "consume any supported media type"));
  }

  return m_ApiClient
      ->callApi(localVarPath, utility::conversions::to_string_t("GET"),
                localVarQueryParams, localVarHttpBody, localVarHeaderParams,
                localVarFormParams, localVarFileParams,
                localVarRequestHttpContentType)
      .then([=, this](web::http::http_response localVarResponse) {
        if (m_ApiClient->getResponseHandler()) {
          m_ApiClient->getResponseHandler()(localVarResponse.status_code(),
                                            localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400) {
          throw ApiException(
              localVarResponse.status_code(),
              utility::conversions::to_string_t("error calling getModsData: ") +
                  localVarResponse.reason_phrase(),
              std::make_shared<std::stringstream>(
                  localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if (localVarResponse.headers().has(
                utility::conversions::to_string_t("Content-Type"))) {
          utility::string_t localVarContentType =
              localVarResponse
                  .headers()[utility::conversions::to_string_t("Content-Type")];
          if (localVarContentType.find(localVarResponseHttpContentType) ==
              std::string::npos) {
            throw ApiException(
                500,
                utility::conversions::to_string_t(
                    "error calling getModsData: unexpected response type: ") +
                    localVarContentType,
                std::make_shared<std::stringstream>(
                    localVarResponse.extract_utf8string(true).get()));
          }
        }

        return localVarResponse.extract_string();
      })
      .then([=, this](utility::string_t localVarResponse) {
        std::vector<std::shared_ptr<Mod>> localVarResult;

        if (localVarResponseHttpContentType ==
            utility::conversions::to_string_t("application/json")) {
          web::json::value localVarJson =
              web::json::value::parse(localVarResponse);
          for (auto &localVarItem : localVarJson.as_array()) {
            std::shared_ptr<Mod> localVarItemObj;
            ModelBase::fromJson(localVarItem, localVarItemObj);
            localVarResult.push_back(localVarItemObj);
          }
        }
        // else if(localVarResponseHttpContentType ==
        // utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else {
          throw ApiException(
              500, utility::conversions::to_string_t(
                       "error calling getModsData: unsupported response type"));
        }

        return localVarResult;
      });
}
pplx::task<std::shared_ptr<Warframes>> WarframeItemsApi::getWarframesData(
    std::shared_ptr<Language> language, boost::optional<utility::string_t> only,
    boost::optional<utility::string_t> remove,
    boost::optional<std::shared_ptr<Language>> acceptLanguage) const {

  // verify the required parameter 'language' is set
  if (language == nullptr) {
    throw ApiException(400, utility::conversions::to_string_t(
                                "Missing required parameter 'language' when "
                                "calling WarframeItemsApi->getWarframesData"));
  }

  std::shared_ptr<const ApiConfiguration> localVarApiConfiguration(
      m_ApiClient->getConfiguration());
  utility::string_t localVarPath =
      utility::conversions::to_string_t("/warframes");

  std::map<utility::string_t, utility::string_t> localVarQueryParams;
  std::map<utility::string_t, utility::string_t> localVarHeaderParams(
      localVarApiConfiguration->getDefaultHeaders());
  std::map<utility::string_t, utility::string_t> localVarFormParams;
  std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

  std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;
  localVarResponseHttpContentTypes.insert(
      utility::conversions::to_string_t("application/json"));

  utility::string_t localVarResponseHttpContentType;

  // use JSON if possible
  if (localVarResponseHttpContentTypes.size() == 0) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // JSON
  else if (localVarResponseHttpContentTypes.find(
               utility::conversions::to_string_t("application/json")) !=
           localVarResponseHttpContentTypes.end()) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // multipart formdata
  else if (localVarResponseHttpContentTypes.find(
               utility::conversions::to_string_t("multipart/form-data")) !=
           localVarResponseHttpContentTypes.end()) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("multipart/form-data");
  } else {
    throw ApiException(400, utility::conversions::to_string_t(
                                "WarframeItemsApi->getWarframesData does not "
                                "produce any supported media type"));
  }

  localVarHeaderParams[utility::conversions::to_string_t("Accept")] =
      localVarResponseHttpContentType;

  std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;

  if (language != nullptr) {
    localVarQueryParams[utility::conversions::to_string_t("language")] =
        ApiClient::parameterToString(language);
  }
  if (only) {
    localVarQueryParams[utility::conversions::to_string_t("only")] =
        ApiClient::parameterToString(*only);
  }
  if (remove) {
    localVarQueryParams[utility::conversions::to_string_t("remove")] =
        ApiClient::parameterToString(*remove);
  }
  if (acceptLanguage && *acceptLanguage != nullptr) {
    localVarHeaderParams[utility::conversions::to_string_t("Accept-Language")] =
        ApiClient::parameterToString(*acceptLanguage);
  }

  std::shared_ptr<IHttpBody> localVarHttpBody;
  utility::string_t localVarRequestHttpContentType;

  // use JSON if possible
  if (localVarConsumeHttpContentTypes.size() == 0 ||
      localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t(
          "application/json")) != localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // multipart formdata
  else if (localVarConsumeHttpContentTypes.find(
               utility::conversions::to_string_t("multipart/form-data")) !=
           localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("multipart/form-data");
  } else if (localVarConsumeHttpContentTypes.find(
                 utility::conversions::to_string_t(
                     "application/x-www-form-urlencoded")) !=
             localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("application/x-www-form-urlencoded");
  } else {
    throw ApiException(415, utility::conversions::to_string_t(
                                "WarframeItemsApi->getWarframesData does not "
                                "consume any supported media type"));
  }

  return m_ApiClient
      ->callApi(localVarPath, utility::conversions::to_string_t("GET"),
                localVarQueryParams, localVarHttpBody, localVarHeaderParams,
                localVarFormParams, localVarFileParams,
                localVarRequestHttpContentType)
      .then([=, this](web::http::http_response localVarResponse) {
        if (m_ApiClient->getResponseHandler()) {
          m_ApiClient->getResponseHandler()(localVarResponse.status_code(),
                                            localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400) {
          throw ApiException(
              localVarResponse.status_code(),
              utility::conversions::to_string_t(
                  "error calling getWarframesData: ") +
                  localVarResponse.reason_phrase(),
              std::make_shared<std::stringstream>(
                  localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if (localVarResponse.headers().has(
                utility::conversions::to_string_t("Content-Type"))) {
          utility::string_t localVarContentType =
              localVarResponse
                  .headers()[utility::conversions::to_string_t("Content-Type")];
          if (localVarContentType.find(localVarResponseHttpContentType) ==
              std::string::npos) {
            throw ApiException(
                500,
                utility::conversions::to_string_t(
                    "error calling getWarframesData: unexpected response "
                    "type: ") +
                    localVarContentType,
                std::make_shared<std::stringstream>(
                    localVarResponse.extract_utf8string(true).get()));
          }
        }

        return localVarResponse.extract_string();
      })
      .then([=, this](utility::string_t localVarResponse) {
        std::shared_ptr<Warframes> localVarResult(new Warframes());

        if (localVarResponseHttpContentType ==
            utility::conversions::to_string_t("application/json")) {
          web::json::value localVarJson =
              web::json::value::parse(localVarResponse);

          ModelBase::fromJson(localVarJson, localVarResult);
        }
        // else if(localVarResponseHttpContentType ==
        // utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else {
          throw ApiException(
              500,
              utility::conversions::to_string_t(
                  "error calling getWarframesData: unsupported response type"));
        }

        return localVarResult;
      });
}
pplx::task<std::shared_ptr<Weapons>> WarframeItemsApi::getWeaponsData(
    std::shared_ptr<Language> language, boost::optional<utility::string_t> only,
    boost::optional<utility::string_t> remove,
    boost::optional<std::shared_ptr<Language>> acceptLanguage) const {

  // verify the required parameter 'language' is set
  if (language == nullptr) {
    throw ApiException(400, utility::conversions::to_string_t(
                                "Missing required parameter 'language' when "
                                "calling WarframeItemsApi->getWeaponsData"));
  }

  std::shared_ptr<const ApiConfiguration> localVarApiConfiguration(
      m_ApiClient->getConfiguration());
  utility::string_t localVarPath =
      utility::conversions::to_string_t("/weapons");

  std::map<utility::string_t, utility::string_t> localVarQueryParams;
  std::map<utility::string_t, utility::string_t> localVarHeaderParams(
      localVarApiConfiguration->getDefaultHeaders());
  std::map<utility::string_t, utility::string_t> localVarFormParams;
  std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

  std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;
  localVarResponseHttpContentTypes.insert(
      utility::conversions::to_string_t("application/json"));

  utility::string_t localVarResponseHttpContentType;

  // use JSON if possible
  if (localVarResponseHttpContentTypes.size() == 0) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // JSON
  else if (localVarResponseHttpContentTypes.find(
               utility::conversions::to_string_t("application/json")) !=
           localVarResponseHttpContentTypes.end()) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // multipart formdata
  else if (localVarResponseHttpContentTypes.find(
               utility::conversions::to_string_t("multipart/form-data")) !=
           localVarResponseHttpContentTypes.end()) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("multipart/form-data");
  } else {
    throw ApiException(400, utility::conversions::to_string_t(
                                "WarframeItemsApi->getWeaponsData does not "
                                "produce any supported media type"));
  }

  localVarHeaderParams[utility::conversions::to_string_t("Accept")] =
      localVarResponseHttpContentType;

  std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;

  if (language != nullptr) {
    localVarQueryParams[utility::conversions::to_string_t("language")] =
        ApiClient::parameterToString(language);
  }
  if (only) {
    localVarQueryParams[utility::conversions::to_string_t("only")] =
        ApiClient::parameterToString(*only);
  }
  if (remove) {
    localVarQueryParams[utility::conversions::to_string_t("remove")] =
        ApiClient::parameterToString(*remove);
  }
  if (acceptLanguage && *acceptLanguage != nullptr) {
    localVarHeaderParams[utility::conversions::to_string_t("Accept-Language")] =
        ApiClient::parameterToString(*acceptLanguage);
  }

  std::shared_ptr<IHttpBody> localVarHttpBody;
  utility::string_t localVarRequestHttpContentType;

  // use JSON if possible
  if (localVarConsumeHttpContentTypes.size() == 0 ||
      localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t(
          "application/json")) != localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // multipart formdata
  else if (localVarConsumeHttpContentTypes.find(
               utility::conversions::to_string_t("multipart/form-data")) !=
           localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("multipart/form-data");
  } else if (localVarConsumeHttpContentTypes.find(
                 utility::conversions::to_string_t(
                     "application/x-www-form-urlencoded")) !=
             localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("application/x-www-form-urlencoded");
  } else {
    throw ApiException(415, utility::conversions::to_string_t(
                                "WarframeItemsApi->getWeaponsData does not "
                                "consume any supported media type"));
  }

  return m_ApiClient
      ->callApi(localVarPath, utility::conversions::to_string_t("GET"),
                localVarQueryParams, localVarHttpBody, localVarHeaderParams,
                localVarFormParams, localVarFileParams,
                localVarRequestHttpContentType)
      .then([=, this](web::http::http_response localVarResponse) {
        if (m_ApiClient->getResponseHandler()) {
          m_ApiClient->getResponseHandler()(localVarResponse.status_code(),
                                            localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400) {
          throw ApiException(
              localVarResponse.status_code(),
              utility::conversions::to_string_t(
                  "error calling getWeaponsData: ") +
                  localVarResponse.reason_phrase(),
              std::make_shared<std::stringstream>(
                  localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if (localVarResponse.headers().has(
                utility::conversions::to_string_t("Content-Type"))) {
          utility::string_t localVarContentType =
              localVarResponse
                  .headers()[utility::conversions::to_string_t("Content-Type")];
          if (localVarContentType.find(localVarResponseHttpContentType) ==
              std::string::npos) {
            throw ApiException(
                500,
                utility::conversions::to_string_t(
                    "error calling getWeaponsData: unexpected response "
                    "type: ") +
                    localVarContentType,
                std::make_shared<std::stringstream>(
                    localVarResponse.extract_utf8string(true).get()));
          }
        }

        return localVarResponse.extract_string();
      })
      .then([=, this](utility::string_t localVarResponse) {
        std::shared_ptr<Weapons> localVarResult(new Weapons());

        if (localVarResponseHttpContentType ==
            utility::conversions::to_string_t("application/json")) {
          web::json::value localVarJson =
              web::json::value::parse(localVarResponse);

          ModelBase::fromJson(localVarJson, localVarResult);
        }
        // else if(localVarResponseHttpContentType ==
        // utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else {
          throw ApiException(
              500,
              utility::conversions::to_string_t(
                  "error calling getWeaponsData: unsupported response type"));
        }

        return localVarResult;
      });
}
pplx::task<std::shared_ptr<Item>> WarframeItemsApi::searchItemData(
    utility::string_t query, std::shared_ptr<Language> language,
    boost::optional<utility::string_t> only,
    boost::optional<utility::string_t> remove,
    boost::optional<utility::string_t> by,
    boost::optional<std::shared_ptr<Language>> acceptLanguage) const {

  // verify the required parameter 'language' is set
  if (language == nullptr) {
    throw ApiException(400, utility::conversions::to_string_t(
                                "Missing required parameter 'language' when "
                                "calling WarframeItemsApi->searchItemData"));
  }

  std::shared_ptr<const ApiConfiguration> localVarApiConfiguration(
      m_ApiClient->getConfiguration());
  utility::string_t localVarPath =
      utility::conversions::to_string_t("/items/{query}");
  boost::replace_all(localVarPath,
                     utility::conversions::to_string_t("{") +
                         utility::conversions::to_string_t("query") +
                         utility::conversions::to_string_t("}"),
                     web::uri::encode_uri(ApiClient::parameterToString(query)));

  std::map<utility::string_t, utility::string_t> localVarQueryParams;
  std::map<utility::string_t, utility::string_t> localVarHeaderParams(
      localVarApiConfiguration->getDefaultHeaders());
  std::map<utility::string_t, utility::string_t> localVarFormParams;
  std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

  std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;
  localVarResponseHttpContentTypes.insert(
      utility::conversions::to_string_t("application/json"));

  utility::string_t localVarResponseHttpContentType;

  // use JSON if possible
  if (localVarResponseHttpContentTypes.size() == 0) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // JSON
  else if (localVarResponseHttpContentTypes.find(
               utility::conversions::to_string_t("application/json")) !=
           localVarResponseHttpContentTypes.end()) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // multipart formdata
  else if (localVarResponseHttpContentTypes.find(
               utility::conversions::to_string_t("multipart/form-data")) !=
           localVarResponseHttpContentTypes.end()) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("multipart/form-data");
  } else {
    throw ApiException(400, utility::conversions::to_string_t(
                                "WarframeItemsApi->searchItemData does not "
                                "produce any supported media type"));
  }

  localVarHeaderParams[utility::conversions::to_string_t("Accept")] =
      localVarResponseHttpContentType;

  std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;

  if (language != nullptr) {
    localVarQueryParams[utility::conversions::to_string_t("language")] =
        ApiClient::parameterToString(language);
  }
  if (only) {
    localVarQueryParams[utility::conversions::to_string_t("only")] =
        ApiClient::parameterToString(*only);
  }
  if (remove) {
    localVarQueryParams[utility::conversions::to_string_t("remove")] =
        ApiClient::parameterToString(*remove);
  }
  if (by) {
    localVarQueryParams[utility::conversions::to_string_t("by")] =
        ApiClient::parameterToString(*by);
  }
  if (acceptLanguage && *acceptLanguage != nullptr) {
    localVarHeaderParams[utility::conversions::to_string_t("Accept-Language")] =
        ApiClient::parameterToString(*acceptLanguage);
  }

  std::shared_ptr<IHttpBody> localVarHttpBody;
  utility::string_t localVarRequestHttpContentType;

  // use JSON if possible
  if (localVarConsumeHttpContentTypes.size() == 0 ||
      localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t(
          "application/json")) != localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // multipart formdata
  else if (localVarConsumeHttpContentTypes.find(
               utility::conversions::to_string_t("multipart/form-data")) !=
           localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("multipart/form-data");
  } else if (localVarConsumeHttpContentTypes.find(
                 utility::conversions::to_string_t(
                     "application/x-www-form-urlencoded")) !=
             localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("application/x-www-form-urlencoded");
  } else {
    throw ApiException(415, utility::conversions::to_string_t(
                                "WarframeItemsApi->searchItemData does not "
                                "consume any supported media type"));
  }

  return m_ApiClient
      ->callApi(localVarPath, utility::conversions::to_string_t("GET"),
                localVarQueryParams, localVarHttpBody, localVarHeaderParams,
                localVarFormParams, localVarFileParams,
                localVarRequestHttpContentType)
      .then([=, this](web::http::http_response localVarResponse) {
        if (m_ApiClient->getResponseHandler()) {
          m_ApiClient->getResponseHandler()(localVarResponse.status_code(),
                                            localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400) {
          throw ApiException(
              localVarResponse.status_code(),
              utility::conversions::to_string_t(
                  "error calling searchItemData: ") +
                  localVarResponse.reason_phrase(),
              std::make_shared<std::stringstream>(
                  localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if (localVarResponse.headers().has(
                utility::conversions::to_string_t("Content-Type"))) {
          utility::string_t localVarContentType =
              localVarResponse
                  .headers()[utility::conversions::to_string_t("Content-Type")];
          if (localVarContentType.find(localVarResponseHttpContentType) ==
              std::string::npos) {
            throw ApiException(
                500,
                utility::conversions::to_string_t(
                    "error calling searchItemData: unexpected response "
                    "type: ") +
                    localVarContentType,
                std::make_shared<std::stringstream>(
                    localVarResponse.extract_utf8string(true).get()));
          }
        }

        return localVarResponse.extract_string();
      })
      .then([=, this](utility::string_t localVarResponse) {
        std::shared_ptr<Item> localVarResult(new Item());

        if (localVarResponseHttpContentType ==
            utility::conversions::to_string_t("application/json")) {
          web::json::value localVarJson =
              web::json::value::parse(localVarResponse);

          ModelBase::fromJson(localVarJson, localVarResult);
        }
        // else if(localVarResponseHttpContentType ==
        // utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else {
          throw ApiException(
              500,
              utility::conversions::to_string_t(
                  "error calling searchItemData: unsupported response type"));
        }

        return localVarResult;
      });
}
pplx::task<std::shared_ptr<Items>> WarframeItemsApi::searchItemsData(
    utility::string_t query, std::shared_ptr<Language> language,
    boost::optional<utility::string_t> only,
    boost::optional<utility::string_t> remove,
    boost::optional<utility::string_t> by,
    boost::optional<std::shared_ptr<Language>> acceptLanguage) const {

  // verify the required parameter 'language' is set
  if (language == nullptr) {
    throw ApiException(400, utility::conversions::to_string_t(
                                "Missing required parameter 'language' when "
                                "calling WarframeItemsApi->searchItemsData"));
  }

  std::shared_ptr<const ApiConfiguration> localVarApiConfiguration(
      m_ApiClient->getConfiguration());
  utility::string_t localVarPath =
      utility::conversions::to_string_t("/items/search/{query}");
  boost::replace_all(localVarPath,
                     utility::conversions::to_string_t("{") +
                         utility::conversions::to_string_t("query") +
                         utility::conversions::to_string_t("}"),
                     web::uri::encode_uri(ApiClient::parameterToString(query)));

  std::map<utility::string_t, utility::string_t> localVarQueryParams;
  std::map<utility::string_t, utility::string_t> localVarHeaderParams(
      localVarApiConfiguration->getDefaultHeaders());
  std::map<utility::string_t, utility::string_t> localVarFormParams;
  std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

  std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;
  localVarResponseHttpContentTypes.insert(
      utility::conversions::to_string_t("application/json"));

  utility::string_t localVarResponseHttpContentType;

  // use JSON if possible
  if (localVarResponseHttpContentTypes.size() == 0) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // JSON
  else if (localVarResponseHttpContentTypes.find(
               utility::conversions::to_string_t("application/json")) !=
           localVarResponseHttpContentTypes.end()) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // multipart formdata
  else if (localVarResponseHttpContentTypes.find(
               utility::conversions::to_string_t("multipart/form-data")) !=
           localVarResponseHttpContentTypes.end()) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("multipart/form-data");
  } else {
    throw ApiException(400, utility::conversions::to_string_t(
                                "WarframeItemsApi->searchItemsData does not "
                                "produce any supported media type"));
  }

  localVarHeaderParams[utility::conversions::to_string_t("Accept")] =
      localVarResponseHttpContentType;

  std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;

  if (language != nullptr) {
    localVarQueryParams[utility::conversions::to_string_t("language")] =
        ApiClient::parameterToString(language);
  }
  if (only) {
    localVarQueryParams[utility::conversions::to_string_t("only")] =
        ApiClient::parameterToString(*only);
  }
  if (remove) {
    localVarQueryParams[utility::conversions::to_string_t("remove")] =
        ApiClient::parameterToString(*remove);
  }
  if (by) {
    localVarQueryParams[utility::conversions::to_string_t("by")] =
        ApiClient::parameterToString(*by);
  }
  if (acceptLanguage && *acceptLanguage != nullptr) {
    localVarHeaderParams[utility::conversions::to_string_t("Accept-Language")] =
        ApiClient::parameterToString(*acceptLanguage);
  }

  std::shared_ptr<IHttpBody> localVarHttpBody;
  utility::string_t localVarRequestHttpContentType;

  // use JSON if possible
  if (localVarConsumeHttpContentTypes.size() == 0 ||
      localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t(
          "application/json")) != localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // multipart formdata
  else if (localVarConsumeHttpContentTypes.find(
               utility::conversions::to_string_t("multipart/form-data")) !=
           localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("multipart/form-data");
  } else if (localVarConsumeHttpContentTypes.find(
                 utility::conversions::to_string_t(
                     "application/x-www-form-urlencoded")) !=
             localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("application/x-www-form-urlencoded");
  } else {
    throw ApiException(415, utility::conversions::to_string_t(
                                "WarframeItemsApi->searchItemsData does not "
                                "consume any supported media type"));
  }

  return m_ApiClient
      ->callApi(localVarPath, utility::conversions::to_string_t("GET"),
                localVarQueryParams, localVarHttpBody, localVarHeaderParams,
                localVarFormParams, localVarFileParams,
                localVarRequestHttpContentType)
      .then([=, this](web::http::http_response localVarResponse) {
        if (m_ApiClient->getResponseHandler()) {
          m_ApiClient->getResponseHandler()(localVarResponse.status_code(),
                                            localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400) {
          throw ApiException(
              localVarResponse.status_code(),
              utility::conversions::to_string_t(
                  "error calling searchItemsData: ") +
                  localVarResponse.reason_phrase(),
              std::make_shared<std::stringstream>(
                  localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if (localVarResponse.headers().has(
                utility::conversions::to_string_t("Content-Type"))) {
          utility::string_t localVarContentType =
              localVarResponse
                  .headers()[utility::conversions::to_string_t("Content-Type")];
          if (localVarContentType.find(localVarResponseHttpContentType) ==
              std::string::npos) {
            throw ApiException(
                500,
                utility::conversions::to_string_t(
                    "error calling searchItemsData: unexpected response "
                    "type: ") +
                    localVarContentType,
                std::make_shared<std::stringstream>(
                    localVarResponse.extract_utf8string(true).get()));
          }
        }

        return localVarResponse.extract_string();
      })
      .then([=, this](utility::string_t localVarResponse) {
        std::shared_ptr<Items> localVarResult(new Items());

        if (localVarResponseHttpContentType ==
            utility::conversions::to_string_t("application/json")) {
          web::json::value localVarJson =
              web::json::value::parse(localVarResponse);

          ModelBase::fromJson(localVarJson, localVarResult);
        }
        // else if(localVarResponseHttpContentType ==
        // utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else {
          throw ApiException(
              500,
              utility::conversions::to_string_t(
                  "error calling searchItemsData: unsupported response type"));
        }

        return localVarResult;
      });
}
pplx::task<std::shared_ptr<Mod>> WarframeItemsApi::searchModData(
    utility::string_t query, std::shared_ptr<Language> language,
    boost::optional<utility::string_t> only,
    boost::optional<utility::string_t> remove,
    boost::optional<utility::string_t> by,
    boost::optional<std::shared_ptr<Language>> acceptLanguage) const {

  // verify the required parameter 'language' is set
  if (language == nullptr) {
    throw ApiException(400, utility::conversions::to_string_t(
                                "Missing required parameter 'language' when "
                                "calling WarframeItemsApi->searchModData"));
  }

  std::shared_ptr<const ApiConfiguration> localVarApiConfiguration(
      m_ApiClient->getConfiguration());
  utility::string_t localVarPath =
      utility::conversions::to_string_t("/mods/{query}");
  boost::replace_all(localVarPath,
                     utility::conversions::to_string_t("{") +
                         utility::conversions::to_string_t("query") +
                         utility::conversions::to_string_t("}"),
                     web::uri::encode_uri(ApiClient::parameterToString(query)));

  std::map<utility::string_t, utility::string_t> localVarQueryParams;
  std::map<utility::string_t, utility::string_t> localVarHeaderParams(
      localVarApiConfiguration->getDefaultHeaders());
  std::map<utility::string_t, utility::string_t> localVarFormParams;
  std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

  std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;
  localVarResponseHttpContentTypes.insert(
      utility::conversions::to_string_t("application/json"));

  utility::string_t localVarResponseHttpContentType;

  // use JSON if possible
  if (localVarResponseHttpContentTypes.size() == 0) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // JSON
  else if (localVarResponseHttpContentTypes.find(
               utility::conversions::to_string_t("application/json")) !=
           localVarResponseHttpContentTypes.end()) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // multipart formdata
  else if (localVarResponseHttpContentTypes.find(
               utility::conversions::to_string_t("multipart/form-data")) !=
           localVarResponseHttpContentTypes.end()) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("multipart/form-data");
  } else {
    throw ApiException(400, utility::conversions::to_string_t(
                                "WarframeItemsApi->searchModData does not "
                                "produce any supported media type"));
  }

  localVarHeaderParams[utility::conversions::to_string_t("Accept")] =
      localVarResponseHttpContentType;

  std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;

  if (language != nullptr) {
    localVarQueryParams[utility::conversions::to_string_t("language")] =
        ApiClient::parameterToString(language);
  }
  if (only) {
    localVarQueryParams[utility::conversions::to_string_t("only")] =
        ApiClient::parameterToString(*only);
  }
  if (remove) {
    localVarQueryParams[utility::conversions::to_string_t("remove")] =
        ApiClient::parameterToString(*remove);
  }
  if (by) {
    localVarQueryParams[utility::conversions::to_string_t("by")] =
        ApiClient::parameterToString(*by);
  }
  if (acceptLanguage && *acceptLanguage != nullptr) {
    localVarHeaderParams[utility::conversions::to_string_t("Accept-Language")] =
        ApiClient::parameterToString(*acceptLanguage);
  }

  std::shared_ptr<IHttpBody> localVarHttpBody;
  utility::string_t localVarRequestHttpContentType;

  // use JSON if possible
  if (localVarConsumeHttpContentTypes.size() == 0 ||
      localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t(
          "application/json")) != localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // multipart formdata
  else if (localVarConsumeHttpContentTypes.find(
               utility::conversions::to_string_t("multipart/form-data")) !=
           localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("multipart/form-data");
  } else if (localVarConsumeHttpContentTypes.find(
                 utility::conversions::to_string_t(
                     "application/x-www-form-urlencoded")) !=
             localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("application/x-www-form-urlencoded");
  } else {
    throw ApiException(415, utility::conversions::to_string_t(
                                "WarframeItemsApi->searchModData does not "
                                "consume any supported media type"));
  }

  return m_ApiClient
      ->callApi(localVarPath, utility::conversions::to_string_t("GET"),
                localVarQueryParams, localVarHttpBody, localVarHeaderParams,
                localVarFormParams, localVarFileParams,
                localVarRequestHttpContentType)
      .then([=, this](web::http::http_response localVarResponse) {
        if (m_ApiClient->getResponseHandler()) {
          m_ApiClient->getResponseHandler()(localVarResponse.status_code(),
                                            localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400) {
          throw ApiException(
              localVarResponse.status_code(),
              utility::conversions::to_string_t(
                  "error calling searchModData: ") +
                  localVarResponse.reason_phrase(),
              std::make_shared<std::stringstream>(
                  localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if (localVarResponse.headers().has(
                utility::conversions::to_string_t("Content-Type"))) {
          utility::string_t localVarContentType =
              localVarResponse
                  .headers()[utility::conversions::to_string_t("Content-Type")];
          if (localVarContentType.find(localVarResponseHttpContentType) ==
              std::string::npos) {
            throw ApiException(
                500,
                utility::conversions::to_string_t(
                    "error calling searchModData: unexpected response type: ") +
                    localVarContentType,
                std::make_shared<std::stringstream>(
                    localVarResponse.extract_utf8string(true).get()));
          }
        }

        return localVarResponse.extract_string();
      })
      .then([=, this](utility::string_t localVarResponse) {
        std::shared_ptr<Mod> localVarResult(new Mod());

        if (localVarResponseHttpContentType ==
            utility::conversions::to_string_t("application/json")) {
          web::json::value localVarJson =
              web::json::value::parse(localVarResponse);

          ModelBase::fromJson(localVarJson, localVarResult);
        }
        // else if(localVarResponseHttpContentType ==
        // utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else {
          throw ApiException(
              500,
              utility::conversions::to_string_t(
                  "error calling searchModData: unsupported response type"));
        }

        return localVarResult;
      });
}
pplx::task<std::vector<std::shared_ptr<Mod>>> WarframeItemsApi::searchModsData(
    utility::string_t query, std::shared_ptr<Language> language,
    boost::optional<utility::string_t> only,
    boost::optional<utility::string_t> remove,
    boost::optional<utility::string_t> by,
    boost::optional<std::shared_ptr<Language>> acceptLanguage) const {

  // verify the required parameter 'language' is set
  if (language == nullptr) {
    throw ApiException(400, utility::conversions::to_string_t(
                                "Missing required parameter 'language' when "
                                "calling WarframeItemsApi->searchModsData"));
  }

  std::shared_ptr<const ApiConfiguration> localVarApiConfiguration(
      m_ApiClient->getConfiguration());
  utility::string_t localVarPath =
      utility::conversions::to_string_t("/mods/search/{query}");
  boost::replace_all(localVarPath,
                     utility::conversions::to_string_t("{") +
                         utility::conversions::to_string_t("query") +
                         utility::conversions::to_string_t("}"),
                     web::uri::encode_uri(ApiClient::parameterToString(query)));

  std::map<utility::string_t, utility::string_t> localVarQueryParams;
  std::map<utility::string_t, utility::string_t> localVarHeaderParams(
      localVarApiConfiguration->getDefaultHeaders());
  std::map<utility::string_t, utility::string_t> localVarFormParams;
  std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

  std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;
  localVarResponseHttpContentTypes.insert(
      utility::conversions::to_string_t("application/json"));

  utility::string_t localVarResponseHttpContentType;

  // use JSON if possible
  if (localVarResponseHttpContentTypes.size() == 0) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // JSON
  else if (localVarResponseHttpContentTypes.find(
               utility::conversions::to_string_t("application/json")) !=
           localVarResponseHttpContentTypes.end()) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // multipart formdata
  else if (localVarResponseHttpContentTypes.find(
               utility::conversions::to_string_t("multipart/form-data")) !=
           localVarResponseHttpContentTypes.end()) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("multipart/form-data");
  } else {
    throw ApiException(400, utility::conversions::to_string_t(
                                "WarframeItemsApi->searchModsData does not "
                                "produce any supported media type"));
  }

  localVarHeaderParams[utility::conversions::to_string_t("Accept")] =
      localVarResponseHttpContentType;

  std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;

  if (language != nullptr) {
    localVarQueryParams[utility::conversions::to_string_t("language")] =
        ApiClient::parameterToString(language);
  }
  if (only) {
    localVarQueryParams[utility::conversions::to_string_t("only")] =
        ApiClient::parameterToString(*only);
  }
  if (remove) {
    localVarQueryParams[utility::conversions::to_string_t("remove")] =
        ApiClient::parameterToString(*remove);
  }
  if (by) {
    localVarQueryParams[utility::conversions::to_string_t("by")] =
        ApiClient::parameterToString(*by);
  }
  if (acceptLanguage && *acceptLanguage != nullptr) {
    localVarHeaderParams[utility::conversions::to_string_t("Accept-Language")] =
        ApiClient::parameterToString(*acceptLanguage);
  }

  std::shared_ptr<IHttpBody> localVarHttpBody;
  utility::string_t localVarRequestHttpContentType;

  // use JSON if possible
  if (localVarConsumeHttpContentTypes.size() == 0 ||
      localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t(
          "application/json")) != localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // multipart formdata
  else if (localVarConsumeHttpContentTypes.find(
               utility::conversions::to_string_t("multipart/form-data")) !=
           localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("multipart/form-data");
  } else if (localVarConsumeHttpContentTypes.find(
                 utility::conversions::to_string_t(
                     "application/x-www-form-urlencoded")) !=
             localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("application/x-www-form-urlencoded");
  } else {
    throw ApiException(415, utility::conversions::to_string_t(
                                "WarframeItemsApi->searchModsData does not "
                                "consume any supported media type"));
  }

  return m_ApiClient
      ->callApi(localVarPath, utility::conversions::to_string_t("GET"),
                localVarQueryParams, localVarHttpBody, localVarHeaderParams,
                localVarFormParams, localVarFileParams,
                localVarRequestHttpContentType)
      .then([=, this](web::http::http_response localVarResponse) {
        if (m_ApiClient->getResponseHandler()) {
          m_ApiClient->getResponseHandler()(localVarResponse.status_code(),
                                            localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400) {
          throw ApiException(
              localVarResponse.status_code(),
              utility::conversions::to_string_t(
                  "error calling searchModsData: ") +
                  localVarResponse.reason_phrase(),
              std::make_shared<std::stringstream>(
                  localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if (localVarResponse.headers().has(
                utility::conversions::to_string_t("Content-Type"))) {
          utility::string_t localVarContentType =
              localVarResponse
                  .headers()[utility::conversions::to_string_t("Content-Type")];
          if (localVarContentType.find(localVarResponseHttpContentType) ==
              std::string::npos) {
            throw ApiException(
                500,
                utility::conversions::to_string_t(
                    "error calling searchModsData: unexpected response "
                    "type: ") +
                    localVarContentType,
                std::make_shared<std::stringstream>(
                    localVarResponse.extract_utf8string(true).get()));
          }
        }

        return localVarResponse.extract_string();
      })
      .then([=, this](utility::string_t localVarResponse) {
        std::vector<std::shared_ptr<Mod>> localVarResult;

        if (localVarResponseHttpContentType ==
            utility::conversions::to_string_t("application/json")) {
          web::json::value localVarJson =
              web::json::value::parse(localVarResponse);
          for (auto &localVarItem : localVarJson.as_array()) {
            std::shared_ptr<Mod> localVarItemObj;
            ModelBase::fromJson(localVarItem, localVarItemObj);
            localVarResult.push_back(localVarItemObj);
          }
        }
        // else if(localVarResponseHttpContentType ==
        // utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else {
          throw ApiException(
              500,
              utility::conversions::to_string_t(
                  "error calling searchModsData: unsupported response type"));
        }

        return localVarResult;
      });
}
pplx::task<std::shared_ptr<Warframe>> WarframeItemsApi::searchWarframeData(
    utility::string_t query, std::shared_ptr<Language> language,
    boost::optional<utility::string_t> only,
    boost::optional<utility::string_t> remove,
    boost::optional<utility::string_t> by,
    boost::optional<std::shared_ptr<Language>> acceptLanguage) const {

  // verify the required parameter 'language' is set
  if (language == nullptr) {
    throw ApiException(400,
                       utility::conversions::to_string_t(
                           "Missing required parameter 'language' when calling "
                           "WarframeItemsApi->searchWarframeData"));
  }

  std::shared_ptr<const ApiConfiguration> localVarApiConfiguration(
      m_ApiClient->getConfiguration());
  utility::string_t localVarPath =
      utility::conversions::to_string_t("/warframes/{query}");
  boost::replace_all(localVarPath,
                     utility::conversions::to_string_t("{") +
                         utility::conversions::to_string_t("query") +
                         utility::conversions::to_string_t("}"),
                     web::uri::encode_uri(ApiClient::parameterToString(query)));

  std::map<utility::string_t, utility::string_t> localVarQueryParams;
  std::map<utility::string_t, utility::string_t> localVarHeaderParams(
      localVarApiConfiguration->getDefaultHeaders());
  std::map<utility::string_t, utility::string_t> localVarFormParams;
  std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

  std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;
  localVarResponseHttpContentTypes.insert(
      utility::conversions::to_string_t("application/json"));

  utility::string_t localVarResponseHttpContentType;

  // use JSON if possible
  if (localVarResponseHttpContentTypes.size() == 0) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // JSON
  else if (localVarResponseHttpContentTypes.find(
               utility::conversions::to_string_t("application/json")) !=
           localVarResponseHttpContentTypes.end()) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // multipart formdata
  else if (localVarResponseHttpContentTypes.find(
               utility::conversions::to_string_t("multipart/form-data")) !=
           localVarResponseHttpContentTypes.end()) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("multipart/form-data");
  } else {
    throw ApiException(400, utility::conversions::to_string_t(
                                "WarframeItemsApi->searchWarframeData does not "
                                "produce any supported media type"));
  }

  localVarHeaderParams[utility::conversions::to_string_t("Accept")] =
      localVarResponseHttpContentType;

  std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;

  if (language != nullptr) {
    localVarQueryParams[utility::conversions::to_string_t("language")] =
        ApiClient::parameterToString(language);
  }
  if (only) {
    localVarQueryParams[utility::conversions::to_string_t("only")] =
        ApiClient::parameterToString(*only);
  }
  if (remove) {
    localVarQueryParams[utility::conversions::to_string_t("remove")] =
        ApiClient::parameterToString(*remove);
  }
  if (by) {
    localVarQueryParams[utility::conversions::to_string_t("by")] =
        ApiClient::parameterToString(*by);
  }
  if (acceptLanguage && *acceptLanguage != nullptr) {
    localVarHeaderParams[utility::conversions::to_string_t("Accept-Language")] =
        ApiClient::parameterToString(*acceptLanguage);
  }

  std::shared_ptr<IHttpBody> localVarHttpBody;
  utility::string_t localVarRequestHttpContentType;

  // use JSON if possible
  if (localVarConsumeHttpContentTypes.size() == 0 ||
      localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t(
          "application/json")) != localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // multipart formdata
  else if (localVarConsumeHttpContentTypes.find(
               utility::conversions::to_string_t("multipart/form-data")) !=
           localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("multipart/form-data");
  } else if (localVarConsumeHttpContentTypes.find(
                 utility::conversions::to_string_t(
                     "application/x-www-form-urlencoded")) !=
             localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("application/x-www-form-urlencoded");
  } else {
    throw ApiException(415, utility::conversions::to_string_t(
                                "WarframeItemsApi->searchWarframeData does not "
                                "consume any supported media type"));
  }

  return m_ApiClient
      ->callApi(localVarPath, utility::conversions::to_string_t("GET"),
                localVarQueryParams, localVarHttpBody, localVarHeaderParams,
                localVarFormParams, localVarFileParams,
                localVarRequestHttpContentType)
      .then([=, this](web::http::http_response localVarResponse) {
        if (m_ApiClient->getResponseHandler()) {
          m_ApiClient->getResponseHandler()(localVarResponse.status_code(),
                                            localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400) {
          throw ApiException(
              localVarResponse.status_code(),
              utility::conversions::to_string_t(
                  "error calling searchWarframeData: ") +
                  localVarResponse.reason_phrase(),
              std::make_shared<std::stringstream>(
                  localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if (localVarResponse.headers().has(
                utility::conversions::to_string_t("Content-Type"))) {
          utility::string_t localVarContentType =
              localVarResponse
                  .headers()[utility::conversions::to_string_t("Content-Type")];
          if (localVarContentType.find(localVarResponseHttpContentType) ==
              std::string::npos) {
            throw ApiException(
                500,
                utility::conversions::to_string_t(
                    "error calling searchWarframeData: unexpected response "
                    "type: ") +
                    localVarContentType,
                std::make_shared<std::stringstream>(
                    localVarResponse.extract_utf8string(true).get()));
          }
        }

        return localVarResponse.extract_string();
      })
      .then([=, this](utility::string_t localVarResponse) {
        std::shared_ptr<Warframe> localVarResult(new Warframe());

        if (localVarResponseHttpContentType ==
            utility::conversions::to_string_t("application/json")) {
          web::json::value localVarJson =
              web::json::value::parse(localVarResponse);

          ModelBase::fromJson(localVarJson, localVarResult);
        }
        // else if(localVarResponseHttpContentType ==
        // utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else {
          throw ApiException(500, utility::conversions::to_string_t(
                                      "error calling searchWarframeData: "
                                      "unsupported response type"));
        }

        return localVarResult;
      });
}
pplx::task<std::shared_ptr<Warframes>> WarframeItemsApi::searchWarframesData(
    utility::string_t query, std::shared_ptr<Language> language,
    boost::optional<utility::string_t> only,
    boost::optional<utility::string_t> remove,
    boost::optional<utility::string_t> by,
    boost::optional<std::shared_ptr<Language>> acceptLanguage) const {

  // verify the required parameter 'language' is set
  if (language == nullptr) {
    throw ApiException(400,
                       utility::conversions::to_string_t(
                           "Missing required parameter 'language' when calling "
                           "WarframeItemsApi->searchWarframesData"));
  }

  std::shared_ptr<const ApiConfiguration> localVarApiConfiguration(
      m_ApiClient->getConfiguration());
  utility::string_t localVarPath =
      utility::conversions::to_string_t("/warframes/search/{query}");
  boost::replace_all(localVarPath,
                     utility::conversions::to_string_t("{") +
                         utility::conversions::to_string_t("query") +
                         utility::conversions::to_string_t("}"),
                     web::uri::encode_uri(ApiClient::parameterToString(query)));

  std::map<utility::string_t, utility::string_t> localVarQueryParams;
  std::map<utility::string_t, utility::string_t> localVarHeaderParams(
      localVarApiConfiguration->getDefaultHeaders());
  std::map<utility::string_t, utility::string_t> localVarFormParams;
  std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

  std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;
  localVarResponseHttpContentTypes.insert(
      utility::conversions::to_string_t("application/json"));

  utility::string_t localVarResponseHttpContentType;

  // use JSON if possible
  if (localVarResponseHttpContentTypes.size() == 0) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // JSON
  else if (localVarResponseHttpContentTypes.find(
               utility::conversions::to_string_t("application/json")) !=
           localVarResponseHttpContentTypes.end()) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // multipart formdata
  else if (localVarResponseHttpContentTypes.find(
               utility::conversions::to_string_t("multipart/form-data")) !=
           localVarResponseHttpContentTypes.end()) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("multipart/form-data");
  } else {
    throw ApiException(400, utility::conversions::to_string_t(
                                "WarframeItemsApi->searchWarframesData does "
                                "not produce any supported media type"));
  }

  localVarHeaderParams[utility::conversions::to_string_t("Accept")] =
      localVarResponseHttpContentType;

  std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;

  if (language != nullptr) {
    localVarQueryParams[utility::conversions::to_string_t("language")] =
        ApiClient::parameterToString(language);
  }
  if (only) {
    localVarQueryParams[utility::conversions::to_string_t("only")] =
        ApiClient::parameterToString(*only);
  }
  if (remove) {
    localVarQueryParams[utility::conversions::to_string_t("remove")] =
        ApiClient::parameterToString(*remove);
  }
  if (by) {
    localVarQueryParams[utility::conversions::to_string_t("by")] =
        ApiClient::parameterToString(*by);
  }
  if (acceptLanguage && *acceptLanguage != nullptr) {
    localVarHeaderParams[utility::conversions::to_string_t("Accept-Language")] =
        ApiClient::parameterToString(*acceptLanguage);
  }

  std::shared_ptr<IHttpBody> localVarHttpBody;
  utility::string_t localVarRequestHttpContentType;

  // use JSON if possible
  if (localVarConsumeHttpContentTypes.size() == 0 ||
      localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t(
          "application/json")) != localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // multipart formdata
  else if (localVarConsumeHttpContentTypes.find(
               utility::conversions::to_string_t("multipart/form-data")) !=
           localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("multipart/form-data");
  } else if (localVarConsumeHttpContentTypes.find(
                 utility::conversions::to_string_t(
                     "application/x-www-form-urlencoded")) !=
             localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("application/x-www-form-urlencoded");
  } else {
    throw ApiException(415, utility::conversions::to_string_t(
                                "WarframeItemsApi->searchWarframesData does "
                                "not consume any supported media type"));
  }

  return m_ApiClient
      ->callApi(localVarPath, utility::conversions::to_string_t("GET"),
                localVarQueryParams, localVarHttpBody, localVarHeaderParams,
                localVarFormParams, localVarFileParams,
                localVarRequestHttpContentType)
      .then([=, this](web::http::http_response localVarResponse) {
        if (m_ApiClient->getResponseHandler()) {
          m_ApiClient->getResponseHandler()(localVarResponse.status_code(),
                                            localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400) {
          throw ApiException(
              localVarResponse.status_code(),
              utility::conversions::to_string_t(
                  "error calling searchWarframesData: ") +
                  localVarResponse.reason_phrase(),
              std::make_shared<std::stringstream>(
                  localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if (localVarResponse.headers().has(
                utility::conversions::to_string_t("Content-Type"))) {
          utility::string_t localVarContentType =
              localVarResponse
                  .headers()[utility::conversions::to_string_t("Content-Type")];
          if (localVarContentType.find(localVarResponseHttpContentType) ==
              std::string::npos) {
            throw ApiException(
                500,
                utility::conversions::to_string_t(
                    "error calling searchWarframesData: unexpected response "
                    "type: ") +
                    localVarContentType,
                std::make_shared<std::stringstream>(
                    localVarResponse.extract_utf8string(true).get()));
          }
        }

        return localVarResponse.extract_string();
      })
      .then([=, this](utility::string_t localVarResponse) {
        std::shared_ptr<Warframes> localVarResult(new Warframes());

        if (localVarResponseHttpContentType ==
            utility::conversions::to_string_t("application/json")) {
          web::json::value localVarJson =
              web::json::value::parse(localVarResponse);

          ModelBase::fromJson(localVarJson, localVarResult);
        }
        // else if(localVarResponseHttpContentType ==
        // utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else {
          throw ApiException(500, utility::conversions::to_string_t(
                                      "error calling searchWarframesData: "
                                      "unsupported response type"));
        }

        return localVarResult;
      });
}
pplx::task<std::shared_ptr<Weapon>> WarframeItemsApi::searchWeaponData(
    utility::string_t query, std::shared_ptr<Language> language,
    boost::optional<utility::string_t> only,
    boost::optional<utility::string_t> remove,
    boost::optional<utility::string_t> by,
    boost::optional<std::shared_ptr<Language>> acceptLanguage) const {

  // verify the required parameter 'language' is set
  if (language == nullptr) {
    throw ApiException(400, utility::conversions::to_string_t(
                                "Missing required parameter 'language' when "
                                "calling WarframeItemsApi->searchWeaponData"));
  }

  std::shared_ptr<const ApiConfiguration> localVarApiConfiguration(
      m_ApiClient->getConfiguration());
  utility::string_t localVarPath =
      utility::conversions::to_string_t("/weapons/{query}");
  boost::replace_all(localVarPath,
                     utility::conversions::to_string_t("{") +
                         utility::conversions::to_string_t("query") +
                         utility::conversions::to_string_t("}"),
                     web::uri::encode_uri(ApiClient::parameterToString(query)));

  std::map<utility::string_t, utility::string_t> localVarQueryParams;
  std::map<utility::string_t, utility::string_t> localVarHeaderParams(
      localVarApiConfiguration->getDefaultHeaders());
  std::map<utility::string_t, utility::string_t> localVarFormParams;
  std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

  std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;
  localVarResponseHttpContentTypes.insert(
      utility::conversions::to_string_t("application/json"));

  utility::string_t localVarResponseHttpContentType;

  // use JSON if possible
  if (localVarResponseHttpContentTypes.size() == 0) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // JSON
  else if (localVarResponseHttpContentTypes.find(
               utility::conversions::to_string_t("application/json")) !=
           localVarResponseHttpContentTypes.end()) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // multipart formdata
  else if (localVarResponseHttpContentTypes.find(
               utility::conversions::to_string_t("multipart/form-data")) !=
           localVarResponseHttpContentTypes.end()) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("multipart/form-data");
  } else {
    throw ApiException(400, utility::conversions::to_string_t(
                                "WarframeItemsApi->searchWeaponData does not "
                                "produce any supported media type"));
  }

  localVarHeaderParams[utility::conversions::to_string_t("Accept")] =
      localVarResponseHttpContentType;

  std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;

  if (language != nullptr) {
    localVarQueryParams[utility::conversions::to_string_t("language")] =
        ApiClient::parameterToString(language);
  }
  if (only) {
    localVarQueryParams[utility::conversions::to_string_t("only")] =
        ApiClient::parameterToString(*only);
  }
  if (remove) {
    localVarQueryParams[utility::conversions::to_string_t("remove")] =
        ApiClient::parameterToString(*remove);
  }
  if (by) {
    localVarQueryParams[utility::conversions::to_string_t("by")] =
        ApiClient::parameterToString(*by);
  }
  if (acceptLanguage && *acceptLanguage != nullptr) {
    localVarHeaderParams[utility::conversions::to_string_t("Accept-Language")] =
        ApiClient::parameterToString(*acceptLanguage);
  }

  std::shared_ptr<IHttpBody> localVarHttpBody;
  utility::string_t localVarRequestHttpContentType;

  // use JSON if possible
  if (localVarConsumeHttpContentTypes.size() == 0 ||
      localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t(
          "application/json")) != localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // multipart formdata
  else if (localVarConsumeHttpContentTypes.find(
               utility::conversions::to_string_t("multipart/form-data")) !=
           localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("multipart/form-data");
  } else if (localVarConsumeHttpContentTypes.find(
                 utility::conversions::to_string_t(
                     "application/x-www-form-urlencoded")) !=
             localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("application/x-www-form-urlencoded");
  } else {
    throw ApiException(415, utility::conversions::to_string_t(
                                "WarframeItemsApi->searchWeaponData does not "
                                "consume any supported media type"));
  }

  return m_ApiClient
      ->callApi(localVarPath, utility::conversions::to_string_t("GET"),
                localVarQueryParams, localVarHttpBody, localVarHeaderParams,
                localVarFormParams, localVarFileParams,
                localVarRequestHttpContentType)
      .then([=, this](web::http::http_response localVarResponse) {
        if (m_ApiClient->getResponseHandler()) {
          m_ApiClient->getResponseHandler()(localVarResponse.status_code(),
                                            localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400) {
          throw ApiException(
              localVarResponse.status_code(),
              utility::conversions::to_string_t(
                  "error calling searchWeaponData: ") +
                  localVarResponse.reason_phrase(),
              std::make_shared<std::stringstream>(
                  localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if (localVarResponse.headers().has(
                utility::conversions::to_string_t("Content-Type"))) {
          utility::string_t localVarContentType =
              localVarResponse
                  .headers()[utility::conversions::to_string_t("Content-Type")];
          if (localVarContentType.find(localVarResponseHttpContentType) ==
              std::string::npos) {
            throw ApiException(
                500,
                utility::conversions::to_string_t(
                    "error calling searchWeaponData: unexpected response "
                    "type: ") +
                    localVarContentType,
                std::make_shared<std::stringstream>(
                    localVarResponse.extract_utf8string(true).get()));
          }
        }

        return localVarResponse.extract_string();
      })
      .then([=, this](utility::string_t localVarResponse) {
        std::shared_ptr<Weapon> localVarResult(new Weapon());

        if (localVarResponseHttpContentType ==
            utility::conversions::to_string_t("application/json")) {
          web::json::value localVarJson =
              web::json::value::parse(localVarResponse);

          ModelBase::fromJson(localVarJson, localVarResult);
        }
        // else if(localVarResponseHttpContentType ==
        // utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else {
          throw ApiException(
              500,
              utility::conversions::to_string_t(
                  "error calling searchWeaponData: unsupported response type"));
        }

        return localVarResult;
      });
}
pplx::task<std::shared_ptr<Weapons>> WarframeItemsApi::searchWeaponsData(
    utility::string_t query, std::shared_ptr<Language> language,
    boost::optional<utility::string_t> only,
    boost::optional<utility::string_t> remove,
    boost::optional<utility::string_t> by,
    boost::optional<std::shared_ptr<Language>> acceptLanguage) const {

  // verify the required parameter 'language' is set
  if (language == nullptr) {
    throw ApiException(400, utility::conversions::to_string_t(
                                "Missing required parameter 'language' when "
                                "calling WarframeItemsApi->searchWeaponsData"));
  }

  std::shared_ptr<const ApiConfiguration> localVarApiConfiguration(
      m_ApiClient->getConfiguration());
  utility::string_t localVarPath =
      utility::conversions::to_string_t("/weapons/search/{query}");
  boost::replace_all(localVarPath,
                     utility::conversions::to_string_t("{") +
                         utility::conversions::to_string_t("query") +
                         utility::conversions::to_string_t("}"),
                     web::uri::encode_uri(ApiClient::parameterToString(query)));

  std::map<utility::string_t, utility::string_t> localVarQueryParams;
  std::map<utility::string_t, utility::string_t> localVarHeaderParams(
      localVarApiConfiguration->getDefaultHeaders());
  std::map<utility::string_t, utility::string_t> localVarFormParams;
  std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

  std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;
  localVarResponseHttpContentTypes.insert(
      utility::conversions::to_string_t("application/json"));

  utility::string_t localVarResponseHttpContentType;

  // use JSON if possible
  if (localVarResponseHttpContentTypes.size() == 0) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // JSON
  else if (localVarResponseHttpContentTypes.find(
               utility::conversions::to_string_t("application/json")) !=
           localVarResponseHttpContentTypes.end()) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // multipart formdata
  else if (localVarResponseHttpContentTypes.find(
               utility::conversions::to_string_t("multipart/form-data")) !=
           localVarResponseHttpContentTypes.end()) {
    localVarResponseHttpContentType =
        utility::conversions::to_string_t("multipart/form-data");
  } else {
    throw ApiException(400, utility::conversions::to_string_t(
                                "WarframeItemsApi->searchWeaponsData does not "
                                "produce any supported media type"));
  }

  localVarHeaderParams[utility::conversions::to_string_t("Accept")] =
      localVarResponseHttpContentType;

  std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;

  if (language != nullptr) {
    localVarQueryParams[utility::conversions::to_string_t("language")] =
        ApiClient::parameterToString(language);
  }
  if (only) {
    localVarQueryParams[utility::conversions::to_string_t("only")] =
        ApiClient::parameterToString(*only);
  }
  if (remove) {
    localVarQueryParams[utility::conversions::to_string_t("remove")] =
        ApiClient::parameterToString(*remove);
  }
  if (by) {
    localVarQueryParams[utility::conversions::to_string_t("by")] =
        ApiClient::parameterToString(*by);
  }
  if (acceptLanguage && *acceptLanguage != nullptr) {
    localVarHeaderParams[utility::conversions::to_string_t("Accept-Language")] =
        ApiClient::parameterToString(*acceptLanguage);
  }

  std::shared_ptr<IHttpBody> localVarHttpBody;
  utility::string_t localVarRequestHttpContentType;

  // use JSON if possible
  if (localVarConsumeHttpContentTypes.size() == 0 ||
      localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t(
          "application/json")) != localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("application/json");
  }
  // multipart formdata
  else if (localVarConsumeHttpContentTypes.find(
               utility::conversions::to_string_t("multipart/form-data")) !=
           localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("multipart/form-data");
  } else if (localVarConsumeHttpContentTypes.find(
                 utility::conversions::to_string_t(
                     "application/x-www-form-urlencoded")) !=
             localVarConsumeHttpContentTypes.end()) {
    localVarRequestHttpContentType =
        utility::conversions::to_string_t("application/x-www-form-urlencoded");
  } else {
    throw ApiException(415, utility::conversions::to_string_t(
                                "WarframeItemsApi->searchWeaponsData does not "
                                "consume any supported media type"));
  }

  return m_ApiClient
      ->callApi(localVarPath, utility::conversions::to_string_t("GET"),
                localVarQueryParams, localVarHttpBody, localVarHeaderParams,
                localVarFormParams, localVarFileParams,
                localVarRequestHttpContentType)
      .then([=, this](web::http::http_response localVarResponse) {
        if (m_ApiClient->getResponseHandler()) {
          m_ApiClient->getResponseHandler()(localVarResponse.status_code(),
                                            localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400) {
          throw ApiException(
              localVarResponse.status_code(),
              utility::conversions::to_string_t(
                  "error calling searchWeaponsData: ") +
                  localVarResponse.reason_phrase(),
              std::make_shared<std::stringstream>(
                  localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if (localVarResponse.headers().has(
                utility::conversions::to_string_t("Content-Type"))) {
          utility::string_t localVarContentType =
              localVarResponse
                  .headers()[utility::conversions::to_string_t("Content-Type")];
          if (localVarContentType.find(localVarResponseHttpContentType) ==
              std::string::npos) {
            throw ApiException(
                500,
                utility::conversions::to_string_t(
                    "error calling searchWeaponsData: unexpected response "
                    "type: ") +
                    localVarContentType,
                std::make_shared<std::stringstream>(
                    localVarResponse.extract_utf8string(true).get()));
          }
        }

        return localVarResponse.extract_string();
      })
      .then([=, this](utility::string_t localVarResponse) {
        std::shared_ptr<Weapons> localVarResult(new Weapons());

        if (localVarResponseHttpContentType ==
            utility::conversions::to_string_t("application/json")) {
          web::json::value localVarJson =
              web::json::value::parse(localVarResponse);

          ModelBase::fromJson(localVarJson, localVarResult);
        }
        // else if(localVarResponseHttpContentType ==
        // utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else {
          throw ApiException(500, utility::conversions::to_string_t(
                                      "error calling searchWeaponsData: "
                                      "unsupported response type"));
        }

        return localVarResult;
      });
}

} // namespace api
} // namespace client
} // namespace openapitools
} // namespace org
