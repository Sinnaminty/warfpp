/**
 * WarframeStat.us API
 * Simple API for data from the game Warframe. [Parser
 * Docs](https://wfcd.github.io/warframe-worldstate-parser/) [Items
 * Types](https://github.com/WFCD/warframe-items/blob/master/index.d.ts)
 *
 * The version of the OpenAPI document: 2.0.8
 * Contact: tobiah@protonmail.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.8.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "CppRestOpenAPIClient/model/Mission.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {

Mission::Mission() {
  m_RewardIsSet = false;
  m_Node = utility::conversions::to_string_t("");
  m_NodeIsSet = false;
  m_NodeKey = utility::conversions::to_string_t("");
  m_NodeKeyIsSet = false;
  m_FactionIsSet = false;
  m_FactionKeyIsSet = false;
  m_MaxEnemyLevel = 0.0;
  m_MaxEnemyLevelIsSet = false;
  m_MinEnemyLevel = 0.0;
  m_MinEnemyLevelIsSet = false;
  m_MaxWaveNum = 0.0;
  m_MaxWaveNumIsSet = false;
  m_TypeIsSet = false;
  m_TypeKeyIsSet = false;
  m_Nightmare = false;
  m_NightmareIsSet = false;
  m_ArchwingRequired = false;
  m_ArchwingRequiredIsSet = false;
  m_IsSharkwing = false;
  m_IsSharkwingIsSet = false;
  m_EnemySpec = utility::conversions::to_string_t("");
  m_EnemySpecIsSet = false;
  m_LevelOverride = utility::conversions::to_string_t("");
  m_LevelOverrideIsSet = false;
  m_AdvancedSpawnersIsSet = false;
  m_RequiredItemsIsSet = false;
  m_ConsumeRequiredItems = false;
  m_ConsumeRequiredItemsIsSet = false;
  m_LeadersAlwaysAllowed = false;
  m_LeadersAlwaysAllowedIsSet = false;
  m_LevelAurasIsSet = false;
  m_Description = utility::conversions::to_string_t("");
  m_DescriptionIsSet = false;
}

Mission::~Mission() {}

void Mission::validate() {
  // TODO: implement validation
}

web::json::value Mission::toJson() const {

  web::json::value val = web::json::value::object();

  if (m_RewardIsSet) {
    val[utility::conversions::to_string_t(U("reward"))] =
        ModelBase::toJson(m_Reward);
  }
  if (m_NodeIsSet) {
    val[utility::conversions::to_string_t(U("node"))] =
        ModelBase::toJson(m_Node);
  }
  if (m_NodeKeyIsSet) {
    val[utility::conversions::to_string_t(U("nodeKey"))] =
        ModelBase::toJson(m_NodeKey);
  }
  if (m_FactionIsSet) {
    val[utility::conversions::to_string_t(U("faction"))] =
        ModelBase::toJson(m_Faction);
  }
  if (m_FactionKeyIsSet) {
    val[utility::conversions::to_string_t(U("factionKey"))] =
        ModelBase::toJson(m_FactionKey);
  }
  if (m_MaxEnemyLevelIsSet) {
    val[utility::conversions::to_string_t(U("maxEnemyLevel"))] =
        ModelBase::toJson(m_MaxEnemyLevel);
  }
  if (m_MinEnemyLevelIsSet) {
    val[utility::conversions::to_string_t(U("minEnemyLevel"))] =
        ModelBase::toJson(m_MinEnemyLevel);
  }
  if (m_MaxWaveNumIsSet) {
    val[utility::conversions::to_string_t(U("maxWaveNum"))] =
        ModelBase::toJson(m_MaxWaveNum);
  }
  if (m_TypeIsSet) {
    val[utility::conversions::to_string_t(U("type"))] =
        ModelBase::toJson(m_Type);
  }
  if (m_TypeKeyIsSet) {
    val[utility::conversions::to_string_t(U("typeKey"))] =
        ModelBase::toJson(m_TypeKey);
  }
  if (m_NightmareIsSet) {
    val[utility::conversions::to_string_t(U("nightmare"))] =
        ModelBase::toJson(m_Nightmare);
  }
  if (m_ArchwingRequiredIsSet) {
    val[utility::conversions::to_string_t(U("archwingRequired"))] =
        ModelBase::toJson(m_ArchwingRequired);
  }
  if (m_IsSharkwingIsSet) {
    val[utility::conversions::to_string_t(U("isSharkwing"))] =
        ModelBase::toJson(m_IsSharkwing);
  }
  if (m_EnemySpecIsSet) {
    val[utility::conversions::to_string_t(U("enemySpec"))] =
        ModelBase::toJson(m_EnemySpec);
  }
  if (m_LevelOverrideIsSet) {
    val[utility::conversions::to_string_t(U("levelOverride"))] =
        ModelBase::toJson(m_LevelOverride);
  }
  if (m_AdvancedSpawnersIsSet) {
    val[utility::conversions::to_string_t(U("advancedSpawners"))] =
        ModelBase::toJson(m_AdvancedSpawners);
  }
  if (m_RequiredItemsIsSet) {
    val[utility::conversions::to_string_t(U("requiredItems"))] =
        ModelBase::toJson(m_RequiredItems);
  }
  if (m_ConsumeRequiredItemsIsSet) {
    val[utility::conversions::to_string_t(U("consumeRequiredItems"))] =
        ModelBase::toJson(m_ConsumeRequiredItems);
  }
  if (m_LeadersAlwaysAllowedIsSet) {
    val[utility::conversions::to_string_t(U("leadersAlwaysAllowed"))] =
        ModelBase::toJson(m_LeadersAlwaysAllowed);
  }
  if (m_LevelAurasIsSet) {
    val[utility::conversions::to_string_t(U("levelAuras"))] =
        ModelBase::toJson(m_LevelAuras);
  }
  if (m_DescriptionIsSet) {
    val[utility::conversions::to_string_t(U("description"))] =
        ModelBase::toJson(m_Description);
  }

  return val;
}

bool Mission::fromJson(const web::json::value &val) {
  bool ok = true;

  if (val.has_field(utility::conversions::to_string_t(U("reward")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("reward")));
    if (!fieldValue.is_null()) {
      std::shared_ptr<Reward> refVal_setReward;
      ok &= ModelBase::fromJson(fieldValue, refVal_setReward);
      setReward(refVal_setReward);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("node")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("node")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setNode;
      ok &= ModelBase::fromJson(fieldValue, refVal_setNode);
      setNode(refVal_setNode);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("nodeKey")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("nodeKey")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setNodeKey;
      ok &= ModelBase::fromJson(fieldValue, refVal_setNodeKey);
      setNodeKey(refVal_setNodeKey);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("faction")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("faction")));
    if (!fieldValue.is_null()) {
      std::shared_ptr<Faction> refVal_setFaction;
      ok &= ModelBase::fromJson(fieldValue, refVal_setFaction);
      setFaction(refVal_setFaction);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("factionKey")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("factionKey")));
    if (!fieldValue.is_null()) {
      std::shared_ptr<Faction> refVal_setFactionKey;
      ok &= ModelBase::fromJson(fieldValue, refVal_setFactionKey);
      setFactionKey(refVal_setFactionKey);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("maxEnemyLevel")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("maxEnemyLevel")));
    if (!fieldValue.is_null()) {
      double refVal_setMaxEnemyLevel;
      ok &= ModelBase::fromJson(fieldValue, refVal_setMaxEnemyLevel);
      setMaxEnemyLevel(refVal_setMaxEnemyLevel);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("minEnemyLevel")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("minEnemyLevel")));
    if (!fieldValue.is_null()) {
      double refVal_setMinEnemyLevel;
      ok &= ModelBase::fromJson(fieldValue, refVal_setMinEnemyLevel);
      setMinEnemyLevel(refVal_setMinEnemyLevel);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("maxWaveNum")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("maxWaveNum")));
    if (!fieldValue.is_null()) {
      double refVal_setMaxWaveNum;
      ok &= ModelBase::fromJson(fieldValue, refVal_setMaxWaveNum);
      setMaxWaveNum(refVal_setMaxWaveNum);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("type")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("type")));
    if (!fieldValue.is_null()) {
      std::shared_ptr<MissionType> refVal_setType;
      ok &= ModelBase::fromJson(fieldValue, refVal_setType);
      setType(refVal_setType);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("typeKey")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("typeKey")));
    if (!fieldValue.is_null()) {
      std::shared_ptr<MissionType> refVal_setTypeKey;
      ok &= ModelBase::fromJson(fieldValue, refVal_setTypeKey);
      setTypeKey(refVal_setTypeKey);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("nightmare")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("nightmare")));
    if (!fieldValue.is_null()) {
      bool refVal_setNightmare;
      ok &= ModelBase::fromJson(fieldValue, refVal_setNightmare);
      setNightmare(refVal_setNightmare);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("archwingRequired")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("archwingRequired")));
    if (!fieldValue.is_null()) {
      bool refVal_setArchwingRequired;
      ok &= ModelBase::fromJson(fieldValue, refVal_setArchwingRequired);
      setArchwingRequired(refVal_setArchwingRequired);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("isSharkwing")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("isSharkwing")));
    if (!fieldValue.is_null()) {
      bool refVal_setIsSharkwing;
      ok &= ModelBase::fromJson(fieldValue, refVal_setIsSharkwing);
      setIsSharkwing(refVal_setIsSharkwing);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("enemySpec")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("enemySpec")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setEnemySpec;
      ok &= ModelBase::fromJson(fieldValue, refVal_setEnemySpec);
      setEnemySpec(refVal_setEnemySpec);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("levelOverride")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("levelOverride")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setLevelOverride;
      ok &= ModelBase::fromJson(fieldValue, refVal_setLevelOverride);
      setLevelOverride(refVal_setLevelOverride);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("advancedSpawners")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("advancedSpawners")));
    if (!fieldValue.is_null()) {
      std::vector<utility::string_t> refVal_setAdvancedSpawners;
      ok &= ModelBase::fromJson(fieldValue, refVal_setAdvancedSpawners);
      setAdvancedSpawners(refVal_setAdvancedSpawners);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("requiredItems")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("requiredItems")));
    if (!fieldValue.is_null()) {
      std::vector<utility::string_t> refVal_setRequiredItems;
      ok &= ModelBase::fromJson(fieldValue, refVal_setRequiredItems);
      setRequiredItems(refVal_setRequiredItems);
    }
  }
  if (val.has_field(
          utility::conversions::to_string_t(U("consumeRequiredItems")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("consumeRequiredItems")));
    if (!fieldValue.is_null()) {
      bool refVal_setConsumeRequiredItems;
      ok &= ModelBase::fromJson(fieldValue, refVal_setConsumeRequiredItems);
      setConsumeRequiredItems(refVal_setConsumeRequiredItems);
    }
  }
  if (val.has_field(
          utility::conversions::to_string_t(U("leadersAlwaysAllowed")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("leadersAlwaysAllowed")));
    if (!fieldValue.is_null()) {
      bool refVal_setLeadersAlwaysAllowed;
      ok &= ModelBase::fromJson(fieldValue, refVal_setLeadersAlwaysAllowed);
      setLeadersAlwaysAllowed(refVal_setLeadersAlwaysAllowed);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("levelAuras")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("levelAuras")));
    if (!fieldValue.is_null()) {
      std::vector<utility::string_t> refVal_setLevelAuras;
      ok &= ModelBase::fromJson(fieldValue, refVal_setLevelAuras);
      setLevelAuras(refVal_setLevelAuras);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("description")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("description")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setDescription;
      ok &= ModelBase::fromJson(fieldValue, refVal_setDescription);
      setDescription(refVal_setDescription);
    }
  }
  return ok;
}

void Mission::toMultipart(std::shared_ptr<MultipartFormData> multipart,
                          const utility::string_t &prefix) const {
  utility::string_t namePrefix = prefix;
  if (namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) !=
                                   utility::conversions::to_string_t(U("."))) {
    namePrefix += utility::conversions::to_string_t(U("."));
  }
  if (m_RewardIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("reward")), m_Reward));
  }
  if (m_NodeIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("node")), m_Node));
  }
  if (m_NodeKeyIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("nodeKey")),
        m_NodeKey));
  }
  if (m_FactionIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("faction")),
        m_Faction));
  }
  if (m_FactionKeyIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("factionKey")),
        m_FactionKey));
  }
  if (m_MaxEnemyLevelIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("maxEnemyLevel")),
        m_MaxEnemyLevel));
  }
  if (m_MinEnemyLevelIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("minEnemyLevel")),
        m_MinEnemyLevel));
  }
  if (m_MaxWaveNumIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("maxWaveNum")),
        m_MaxWaveNum));
  }
  if (m_TypeIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("type")), m_Type));
  }
  if (m_TypeKeyIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("typeKey")),
        m_TypeKey));
  }
  if (m_NightmareIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("nightmare")),
        m_Nightmare));
  }
  if (m_ArchwingRequiredIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("archwingRequired")),
        m_ArchwingRequired));
  }
  if (m_IsSharkwingIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("isSharkwing")),
        m_IsSharkwing));
  }
  if (m_EnemySpecIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("enemySpec")),
        m_EnemySpec));
  }
  if (m_LevelOverrideIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("levelOverride")),
        m_LevelOverride));
  }
  if (m_AdvancedSpawnersIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("advancedSpawners")),
        m_AdvancedSpawners));
  }
  if (m_RequiredItemsIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("requiredItems")),
        m_RequiredItems));
  }
  if (m_ConsumeRequiredItemsIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix +
            utility::conversions::to_string_t(U("consumeRequiredItems")),
        m_ConsumeRequiredItems));
  }
  if (m_LeadersAlwaysAllowedIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix +
            utility::conversions::to_string_t(U("leadersAlwaysAllowed")),
        m_LeadersAlwaysAllowed));
  }
  if (m_LevelAurasIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("levelAuras")),
        m_LevelAuras));
  }
  if (m_DescriptionIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("description")),
        m_Description));
  }
}

bool Mission::fromMultiPart(std::shared_ptr<MultipartFormData> multipart,
                            const utility::string_t &prefix) {
  bool ok = true;
  utility::string_t namePrefix = prefix;
  if (namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) !=
                                   utility::conversions::to_string_t(U("."))) {
    namePrefix += utility::conversions::to_string_t(U("."));
  }

  if (multipart->hasContent(utility::conversions::to_string_t(U("reward")))) {
    std::shared_ptr<Reward> refVal_setReward;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("reward"))),
        refVal_setReward);
    setReward(refVal_setReward);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("node")))) {
    utility::string_t refVal_setNode;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("node"))),
        refVal_setNode);
    setNode(refVal_setNode);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("nodeKey")))) {
    utility::string_t refVal_setNodeKey;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("nodeKey"))),
        refVal_setNodeKey);
    setNodeKey(refVal_setNodeKey);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("faction")))) {
    std::shared_ptr<Faction> refVal_setFaction;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("faction"))),
        refVal_setFaction);
    setFaction(refVal_setFaction);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("factionKey")))) {
    std::shared_ptr<Faction> refVal_setFactionKey;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("factionKey"))),
        refVal_setFactionKey);
    setFactionKey(refVal_setFactionKey);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("maxEnemyLevel")))) {
    double refVal_setMaxEnemyLevel;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("maxEnemyLevel"))),
        refVal_setMaxEnemyLevel);
    setMaxEnemyLevel(refVal_setMaxEnemyLevel);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("minEnemyLevel")))) {
    double refVal_setMinEnemyLevel;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("minEnemyLevel"))),
        refVal_setMinEnemyLevel);
    setMinEnemyLevel(refVal_setMinEnemyLevel);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("maxWaveNum")))) {
    double refVal_setMaxWaveNum;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("maxWaveNum"))),
        refVal_setMaxWaveNum);
    setMaxWaveNum(refVal_setMaxWaveNum);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("type")))) {
    std::shared_ptr<MissionType> refVal_setType;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("type"))),
        refVal_setType);
    setType(refVal_setType);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("typeKey")))) {
    std::shared_ptr<MissionType> refVal_setTypeKey;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("typeKey"))),
        refVal_setTypeKey);
    setTypeKey(refVal_setTypeKey);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("nightmare")))) {
    bool refVal_setNightmare;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("nightmare"))),
        refVal_setNightmare);
    setNightmare(refVal_setNightmare);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("archwingRequired")))) {
    bool refVal_setArchwingRequired;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("archwingRequired"))),
        refVal_setArchwingRequired);
    setArchwingRequired(refVal_setArchwingRequired);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("isSharkwing")))) {
    bool refVal_setIsSharkwing;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("isSharkwing"))),
        refVal_setIsSharkwing);
    setIsSharkwing(refVal_setIsSharkwing);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("enemySpec")))) {
    utility::string_t refVal_setEnemySpec;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("enemySpec"))),
        refVal_setEnemySpec);
    setEnemySpec(refVal_setEnemySpec);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("levelOverride")))) {
    utility::string_t refVal_setLevelOverride;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("levelOverride"))),
        refVal_setLevelOverride);
    setLevelOverride(refVal_setLevelOverride);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("advancedSpawners")))) {
    std::vector<utility::string_t> refVal_setAdvancedSpawners;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("advancedSpawners"))),
        refVal_setAdvancedSpawners);
    setAdvancedSpawners(refVal_setAdvancedSpawners);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("requiredItems")))) {
    std::vector<utility::string_t> refVal_setRequiredItems;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("requiredItems"))),
        refVal_setRequiredItems);
    setRequiredItems(refVal_setRequiredItems);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("consumeRequiredItems")))) {
    bool refVal_setConsumeRequiredItems;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("consumeRequiredItems"))),
        refVal_setConsumeRequiredItems);
    setConsumeRequiredItems(refVal_setConsumeRequiredItems);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("leadersAlwaysAllowed")))) {
    bool refVal_setLeadersAlwaysAllowed;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("leadersAlwaysAllowed"))),
        refVal_setLeadersAlwaysAllowed);
    setLeadersAlwaysAllowed(refVal_setLeadersAlwaysAllowed);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("levelAuras")))) {
    std::vector<utility::string_t> refVal_setLevelAuras;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("levelAuras"))),
        refVal_setLevelAuras);
    setLevelAuras(refVal_setLevelAuras);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("description")))) {
    utility::string_t refVal_setDescription;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("description"))),
        refVal_setDescription);
    setDescription(refVal_setDescription);
  }
  return ok;
}

std::shared_ptr<Reward> Mission::getReward() const { return m_Reward; }

void Mission::setReward(const std::shared_ptr<Reward> &value) {
  m_Reward = value;
  m_RewardIsSet = true;
}

bool Mission::rewardIsSet() const { return m_RewardIsSet; }

void Mission::unsetReward() { m_RewardIsSet = false; }
utility::string_t Mission::getNode() const { return m_Node; }

void Mission::setNode(const utility::string_t &value) {
  m_Node = value;
  m_NodeIsSet = true;
}

bool Mission::nodeIsSet() const { return m_NodeIsSet; }

void Mission::unsetNode() { m_NodeIsSet = false; }
utility::string_t Mission::getNodeKey() const { return m_NodeKey; }

void Mission::setNodeKey(const utility::string_t &value) {
  m_NodeKey = value;
  m_NodeKeyIsSet = true;
}

bool Mission::nodeKeyIsSet() const { return m_NodeKeyIsSet; }

void Mission::unsetNodeKey() { m_NodeKeyIsSet = false; }
std::shared_ptr<Faction> Mission::getFaction() const { return m_Faction; }

void Mission::setFaction(const std::shared_ptr<Faction> &value) {
  m_Faction = value;
  m_FactionIsSet = true;
}

bool Mission::factionIsSet() const { return m_FactionIsSet; }

void Mission::unsetFaction() { m_FactionIsSet = false; }
std::shared_ptr<Faction> Mission::getFactionKey() const { return m_FactionKey; }

void Mission::setFactionKey(const std::shared_ptr<Faction> &value) {
  m_FactionKey = value;
  m_FactionKeyIsSet = true;
}

bool Mission::factionKeyIsSet() const { return m_FactionKeyIsSet; }

void Mission::unsetFactionKey() { m_FactionKeyIsSet = false; }
double Mission::getMaxEnemyLevel() const { return m_MaxEnemyLevel; }

void Mission::setMaxEnemyLevel(double value) {
  m_MaxEnemyLevel = value;
  m_MaxEnemyLevelIsSet = true;
}

bool Mission::maxEnemyLevelIsSet() const { return m_MaxEnemyLevelIsSet; }

void Mission::unsetMaxEnemyLevel() { m_MaxEnemyLevelIsSet = false; }
double Mission::getMinEnemyLevel() const { return m_MinEnemyLevel; }

void Mission::setMinEnemyLevel(double value) {
  m_MinEnemyLevel = value;
  m_MinEnemyLevelIsSet = true;
}

bool Mission::minEnemyLevelIsSet() const { return m_MinEnemyLevelIsSet; }

void Mission::unsetMinEnemyLevel() { m_MinEnemyLevelIsSet = false; }
double Mission::getMaxWaveNum() const { return m_MaxWaveNum; }

void Mission::setMaxWaveNum(double value) {
  m_MaxWaveNum = value;
  m_MaxWaveNumIsSet = true;
}

bool Mission::maxWaveNumIsSet() const { return m_MaxWaveNumIsSet; }

void Mission::unsetMaxWaveNum() { m_MaxWaveNumIsSet = false; }
std::shared_ptr<MissionType> Mission::getType() const { return m_Type; }

void Mission::setType(const std::shared_ptr<MissionType> &value) {
  m_Type = value;
  m_TypeIsSet = true;
}

bool Mission::typeIsSet() const { return m_TypeIsSet; }

void Mission::unsetType() { m_TypeIsSet = false; }
std::shared_ptr<MissionType> Mission::getTypeKey() const { return m_TypeKey; }

void Mission::setTypeKey(const std::shared_ptr<MissionType> &value) {
  m_TypeKey = value;
  m_TypeKeyIsSet = true;
}

bool Mission::typeKeyIsSet() const { return m_TypeKeyIsSet; }

void Mission::unsetTypeKey() { m_TypeKeyIsSet = false; }
bool Mission::isNightmare() const { return m_Nightmare; }

void Mission::setNightmare(bool value) {
  m_Nightmare = value;
  m_NightmareIsSet = true;
}

bool Mission::nightmareIsSet() const { return m_NightmareIsSet; }

void Mission::unsetNightmare() { m_NightmareIsSet = false; }
bool Mission::isArchwingRequired() const { return m_ArchwingRequired; }

void Mission::setArchwingRequired(bool value) {
  m_ArchwingRequired = value;
  m_ArchwingRequiredIsSet = true;
}

bool Mission::archwingRequiredIsSet() const { return m_ArchwingRequiredIsSet; }

void Mission::unsetArchwingRequired() { m_ArchwingRequiredIsSet = false; }
bool Mission::isIsSharkwing() const { return m_IsSharkwing; }

void Mission::setIsSharkwing(bool value) {
  m_IsSharkwing = value;
  m_IsSharkwingIsSet = true;
}

bool Mission::isSharkwingIsSet() const { return m_IsSharkwingIsSet; }

void Mission::unsetIsSharkwing() { m_IsSharkwingIsSet = false; }
utility::string_t Mission::getEnemySpec() const { return m_EnemySpec; }

void Mission::setEnemySpec(const utility::string_t &value) {
  m_EnemySpec = value;
  m_EnemySpecIsSet = true;
}

bool Mission::enemySpecIsSet() const { return m_EnemySpecIsSet; }

void Mission::unsetEnemySpec() { m_EnemySpecIsSet = false; }
utility::string_t Mission::getLevelOverride() const { return m_LevelOverride; }

void Mission::setLevelOverride(const utility::string_t &value) {
  m_LevelOverride = value;
  m_LevelOverrideIsSet = true;
}

bool Mission::levelOverrideIsSet() const { return m_LevelOverrideIsSet; }

void Mission::unsetLevelOverride() { m_LevelOverrideIsSet = false; }
std::vector<utility::string_t> &Mission::getAdvancedSpawners() {
  return m_AdvancedSpawners;
}

void Mission::setAdvancedSpawners(const std::vector<utility::string_t> &value) {
  m_AdvancedSpawners = value;
  m_AdvancedSpawnersIsSet = true;
}

bool Mission::advancedSpawnersIsSet() const { return m_AdvancedSpawnersIsSet; }

void Mission::unsetAdvancedSpawners() { m_AdvancedSpawnersIsSet = false; }
std::vector<utility::string_t> &Mission::getRequiredItems() {
  return m_RequiredItems;
}

void Mission::setRequiredItems(const std::vector<utility::string_t> &value) {
  m_RequiredItems = value;
  m_RequiredItemsIsSet = true;
}

bool Mission::requiredItemsIsSet() const { return m_RequiredItemsIsSet; }

void Mission::unsetRequiredItems() { m_RequiredItemsIsSet = false; }
bool Mission::isConsumeRequiredItems() const { return m_ConsumeRequiredItems; }

void Mission::setConsumeRequiredItems(bool value) {
  m_ConsumeRequiredItems = value;
  m_ConsumeRequiredItemsIsSet = true;
}

bool Mission::consumeRequiredItemsIsSet() const {
  return m_ConsumeRequiredItemsIsSet;
}

void Mission::unsetConsumeRequiredItems() {
  m_ConsumeRequiredItemsIsSet = false;
}
bool Mission::isLeadersAlwaysAllowed() const { return m_LeadersAlwaysAllowed; }

void Mission::setLeadersAlwaysAllowed(bool value) {
  m_LeadersAlwaysAllowed = value;
  m_LeadersAlwaysAllowedIsSet = true;
}

bool Mission::leadersAlwaysAllowedIsSet() const {
  return m_LeadersAlwaysAllowedIsSet;
}

void Mission::unsetLeadersAlwaysAllowed() {
  m_LeadersAlwaysAllowedIsSet = false;
}
std::vector<utility::string_t> &Mission::getLevelAuras() {
  return m_LevelAuras;
}

void Mission::setLevelAuras(const std::vector<utility::string_t> &value) {
  m_LevelAuras = value;
  m_LevelAurasIsSet = true;
}

bool Mission::levelAurasIsSet() const { return m_LevelAurasIsSet; }

void Mission::unsetLevelAuras() { m_LevelAurasIsSet = false; }
utility::string_t Mission::getDescription() const { return m_Description; }

void Mission::setDescription(const utility::string_t &value) {
  m_Description = value;
  m_DescriptionIsSet = true;
}

bool Mission::descriptionIsSet() const { return m_DescriptionIsSet; }

void Mission::unsetDescription() { m_DescriptionIsSet = false; }
} // namespace model
} // namespace client
} // namespace openapitools
} // namespace org
