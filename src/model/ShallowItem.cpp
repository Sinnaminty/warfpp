/**
 * WarframeStat.us API
 * Simple API for data from the game Warframe. [Parser
 * Docs](https://wfcd.github.io/warframe-worldstate-parser/) [Items
 * Types](https://github.com/WFCD/warframe-items/blob/master/index.d.ts)
 *
 * The version of the OpenAPI document: 2.0.8
 * Contact: tobiah@protonmail.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.8.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "CppRestOpenAPIClient/model/ShallowItem.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {

ShallowItem::ShallowItem() {
  m_Name = utility::conversions::to_string_t("");
  m_NameIsSet = false;
  m_UniqueName = utility::conversions::to_string_t("");
  m_UniqueNameIsSet = false;
  m_Description = utility::conversions::to_string_t("");
  m_DescriptionIsSet = false;
  m_Type = utility::conversions::to_string_t("");
  m_TypeIsSet = false;
  m_Tradable = false;
  m_TradableIsSet = false;
  m_Category = utility::conversions::to_string_t("");
  m_CategoryIsSet = false;
  m_ProductCategory = utility::conversions::to_string_t("");
  m_ProductCategoryIsSet = false;
}

ShallowItem::~ShallowItem() {}

void ShallowItem::validate() {
  // TODO: implement validation
}

web::json::value ShallowItem::toJson() const {

  web::json::value val = web::json::value::object();

  if (m_NameIsSet) {
    val[utility::conversions::to_string_t(U("name"))] =
        ModelBase::toJson(m_Name);
  }
  if (m_UniqueNameIsSet) {
    val[utility::conversions::to_string_t(U("uniqueName"))] =
        ModelBase::toJson(m_UniqueName);
  }
  if (m_DescriptionIsSet) {
    val[utility::conversions::to_string_t(U("description"))] =
        ModelBase::toJson(m_Description);
  }
  if (m_TypeIsSet) {
    val[utility::conversions::to_string_t(U("type"))] =
        ModelBase::toJson(m_Type);
  }
  if (m_TradableIsSet) {
    val[utility::conversions::to_string_t(U("tradable"))] =
        ModelBase::toJson(m_Tradable);
  }
  if (m_CategoryIsSet) {
    val[utility::conversions::to_string_t(U("category"))] =
        ModelBase::toJson(m_Category);
  }
  if (m_ProductCategoryIsSet) {
    val[utility::conversions::to_string_t(U("productCategory"))] =
        ModelBase::toJson(m_ProductCategory);
  }

  return val;
}

bool ShallowItem::fromJson(const web::json::value &val) {
  bool ok = true;

  if (val.has_field(utility::conversions::to_string_t(U("name")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("name")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setName;
      ok &= ModelBase::fromJson(fieldValue, refVal_setName);
      setName(refVal_setName);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("uniqueName")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("uniqueName")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setUniqueName;
      ok &= ModelBase::fromJson(fieldValue, refVal_setUniqueName);
      setUniqueName(refVal_setUniqueName);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("description")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("description")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setDescription;
      ok &= ModelBase::fromJson(fieldValue, refVal_setDescription);
      setDescription(refVal_setDescription);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("type")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("type")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setType;
      ok &= ModelBase::fromJson(fieldValue, refVal_setType);
      setType(refVal_setType);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("tradable")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("tradable")));
    if (!fieldValue.is_null()) {
      bool refVal_setTradable;
      ok &= ModelBase::fromJson(fieldValue, refVal_setTradable);
      setTradable(refVal_setTradable);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("category")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("category")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setCategory;
      ok &= ModelBase::fromJson(fieldValue, refVal_setCategory);
      setCategory(refVal_setCategory);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("productCategory")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("productCategory")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setProductCategory;
      ok &= ModelBase::fromJson(fieldValue, refVal_setProductCategory);
      setProductCategory(refVal_setProductCategory);
    }
  }
  return ok;
}

void ShallowItem::toMultipart(std::shared_ptr<MultipartFormData> multipart,
                              const utility::string_t &prefix) const {
  utility::string_t namePrefix = prefix;
  if (namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) !=
                                   utility::conversions::to_string_t(U("."))) {
    namePrefix += utility::conversions::to_string_t(U("."));
  }
  if (m_NameIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("name")), m_Name));
  }
  if (m_UniqueNameIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("uniqueName")),
        m_UniqueName));
  }
  if (m_DescriptionIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("description")),
        m_Description));
  }
  if (m_TypeIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("type")), m_Type));
  }
  if (m_TradableIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("tradable")),
        m_Tradable));
  }
  if (m_CategoryIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("category")),
        m_Category));
  }
  if (m_ProductCategoryIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("productCategory")),
        m_ProductCategory));
  }
}

bool ShallowItem::fromMultiPart(std::shared_ptr<MultipartFormData> multipart,
                                const utility::string_t &prefix) {
  bool ok = true;
  utility::string_t namePrefix = prefix;
  if (namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) !=
                                   utility::conversions::to_string_t(U("."))) {
    namePrefix += utility::conversions::to_string_t(U("."));
  }

  if (multipart->hasContent(utility::conversions::to_string_t(U("name")))) {
    utility::string_t refVal_setName;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("name"))),
        refVal_setName);
    setName(refVal_setName);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("uniqueName")))) {
    utility::string_t refVal_setUniqueName;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("uniqueName"))),
        refVal_setUniqueName);
    setUniqueName(refVal_setUniqueName);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("description")))) {
    utility::string_t refVal_setDescription;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("description"))),
        refVal_setDescription);
    setDescription(refVal_setDescription);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("type")))) {
    utility::string_t refVal_setType;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("type"))),
        refVal_setType);
    setType(refVal_setType);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("tradable")))) {
    bool refVal_setTradable;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("tradable"))),
        refVal_setTradable);
    setTradable(refVal_setTradable);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("category")))) {
    utility::string_t refVal_setCategory;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("category"))),
        refVal_setCategory);
    setCategory(refVal_setCategory);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("productCategory")))) {
    utility::string_t refVal_setProductCategory;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("productCategory"))),
        refVal_setProductCategory);
    setProductCategory(refVal_setProductCategory);
  }
  return ok;
}

utility::string_t ShallowItem::getName() const { return m_Name; }

void ShallowItem::setName(const utility::string_t &value) {
  m_Name = value;
  m_NameIsSet = true;
}

bool ShallowItem::nameIsSet() const { return m_NameIsSet; }

void ShallowItem::unsetName() { m_NameIsSet = false; }
utility::string_t ShallowItem::getUniqueName() const { return m_UniqueName; }

void ShallowItem::setUniqueName(const utility::string_t &value) {
  m_UniqueName = value;
  m_UniqueNameIsSet = true;
}

bool ShallowItem::uniqueNameIsSet() const { return m_UniqueNameIsSet; }

void ShallowItem::unsetUniqueName() { m_UniqueNameIsSet = false; }
utility::string_t ShallowItem::getDescription() const { return m_Description; }

void ShallowItem::setDescription(const utility::string_t &value) {
  m_Description = value;
  m_DescriptionIsSet = true;
}

bool ShallowItem::descriptionIsSet() const { return m_DescriptionIsSet; }

void ShallowItem::unsetDescription() { m_DescriptionIsSet = false; }
utility::string_t ShallowItem::getType() const { return m_Type; }

void ShallowItem::setType(const utility::string_t &value) {
  m_Type = value;
  m_TypeIsSet = true;
}

bool ShallowItem::typeIsSet() const { return m_TypeIsSet; }

void ShallowItem::unsetType() { m_TypeIsSet = false; }
bool ShallowItem::isTradable() const { return m_Tradable; }

void ShallowItem::setTradable(bool value) {
  m_Tradable = value;
  m_TradableIsSet = true;
}

bool ShallowItem::tradableIsSet() const { return m_TradableIsSet; }

void ShallowItem::unsetTradable() { m_TradableIsSet = false; }
utility::string_t ShallowItem::getCategory() const { return m_Category; }

void ShallowItem::setCategory(const utility::string_t &value) {
  m_Category = value;
  m_CategoryIsSet = true;
}

bool ShallowItem::categoryIsSet() const { return m_CategoryIsSet; }

void ShallowItem::unsetCategory() { m_CategoryIsSet = false; }
utility::string_t ShallowItem::getProductCategory() const {
  return m_ProductCategory;
}

void ShallowItem::setProductCategory(const utility::string_t &value) {
  m_ProductCategory = value;
  m_ProductCategoryIsSet = true;
}

bool ShallowItem::productCategoryIsSet() const {
  return m_ProductCategoryIsSet;
}

void ShallowItem::unsetProductCategory() { m_ProductCategoryIsSet = false; }
} // namespace model
} // namespace client
} // namespace openapitools
} // namespace org
