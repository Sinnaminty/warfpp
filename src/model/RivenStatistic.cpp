/**
 * WarframeStat.us API
 * Simple API for data from the game Warframe. [Parser
 * Docs](https://wfcd.github.io/warframe-worldstate-parser/) [Items
 * Types](https://github.com/WFCD/warframe-items/blob/master/index.d.ts)
 *
 * The version of the OpenAPI document: 2.0.8
 * Contact: tobiah@protonmail.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.8.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "CppRestOpenAPIClient/model/RivenStatistic.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {

RivenStatistic::RivenStatistic() {
  m_ItemType = utility::conversions::to_string_t("");
  m_ItemTypeIsSet = false;
  m_Compatability = utility::conversions::to_string_t("");
  m_CompatabilityIsSet = false;
  m_Rerolled = false;
  m_RerolledIsSet = false;
  m_Avg = 0.0f;
  m_AvgIsSet = false;
  m_Stddev = 0.0f;
  m_StddevIsSet = false;
  m_Min = 0.0f;
  m_MinIsSet = false;
  m_Max = 0.0f;
  m_MaxIsSet = false;
  m_Pop = 0.0f;
  m_PopIsSet = false;
  m_Median = 0.0f;
  m_MedianIsSet = false;
}

RivenStatistic::~RivenStatistic() {}

void RivenStatistic::validate() {
  // TODO: implement validation
}

web::json::value RivenStatistic::toJson() const {

  web::json::value val = web::json::value::object();

  if (m_ItemTypeIsSet) {
    val[utility::conversions::to_string_t(U("itemType"))] =
        ModelBase::toJson(m_ItemType);
  }
  if (m_CompatabilityIsSet) {
    val[utility::conversions::to_string_t(U("compatability"))] =
        ModelBase::toJson(m_Compatability);
  }
  if (m_RerolledIsSet) {
    val[utility::conversions::to_string_t(U("rerolled"))] =
        ModelBase::toJson(m_Rerolled);
  }
  if (m_AvgIsSet) {
    val[utility::conversions::to_string_t(U("avg"))] = ModelBase::toJson(m_Avg);
  }
  if (m_StddevIsSet) {
    val[utility::conversions::to_string_t(U("stddev"))] =
        ModelBase::toJson(m_Stddev);
  }
  if (m_MinIsSet) {
    val[utility::conversions::to_string_t(U("min"))] = ModelBase::toJson(m_Min);
  }
  if (m_MaxIsSet) {
    val[utility::conversions::to_string_t(U("max"))] = ModelBase::toJson(m_Max);
  }
  if (m_PopIsSet) {
    val[utility::conversions::to_string_t(U("pop"))] = ModelBase::toJson(m_Pop);
  }
  if (m_MedianIsSet) {
    val[utility::conversions::to_string_t(U("median"))] =
        ModelBase::toJson(m_Median);
  }

  return val;
}

bool RivenStatistic::fromJson(const web::json::value &val) {
  bool ok = true;

  if (val.has_field(utility::conversions::to_string_t(U("itemType")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("itemType")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setItemType;
      ok &= ModelBase::fromJson(fieldValue, refVal_setItemType);
      setItemType(refVal_setItemType);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("compatability")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("compatability")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setCompatability;
      ok &= ModelBase::fromJson(fieldValue, refVal_setCompatability);
      setCompatability(refVal_setCompatability);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("rerolled")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("rerolled")));
    if (!fieldValue.is_null()) {
      bool refVal_setRerolled;
      ok &= ModelBase::fromJson(fieldValue, refVal_setRerolled);
      setRerolled(refVal_setRerolled);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("avg")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("avg")));
    if (!fieldValue.is_null()) {
      float refVal_setAvg;
      ok &= ModelBase::fromJson(fieldValue, refVal_setAvg);
      setAvg(refVal_setAvg);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("stddev")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("stddev")));
    if (!fieldValue.is_null()) {
      float refVal_setStddev;
      ok &= ModelBase::fromJson(fieldValue, refVal_setStddev);
      setStddev(refVal_setStddev);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("min")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("min")));
    if (!fieldValue.is_null()) {
      float refVal_setMin;
      ok &= ModelBase::fromJson(fieldValue, refVal_setMin);
      setMin(refVal_setMin);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("max")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("max")));
    if (!fieldValue.is_null()) {
      float refVal_setMax;
      ok &= ModelBase::fromJson(fieldValue, refVal_setMax);
      setMax(refVal_setMax);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("pop")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("pop")));
    if (!fieldValue.is_null()) {
      float refVal_setPop;
      ok &= ModelBase::fromJson(fieldValue, refVal_setPop);
      setPop(refVal_setPop);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("median")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("median")));
    if (!fieldValue.is_null()) {
      float refVal_setMedian;
      ok &= ModelBase::fromJson(fieldValue, refVal_setMedian);
      setMedian(refVal_setMedian);
    }
  }
  return ok;
}

void RivenStatistic::toMultipart(std::shared_ptr<MultipartFormData> multipart,
                                 const utility::string_t &prefix) const {
  utility::string_t namePrefix = prefix;
  if (namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) !=
                                   utility::conversions::to_string_t(U("."))) {
    namePrefix += utility::conversions::to_string_t(U("."));
  }
  if (m_ItemTypeIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("itemType")),
        m_ItemType));
  }
  if (m_CompatabilityIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("compatability")),
        m_Compatability));
  }
  if (m_RerolledIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("rerolled")),
        m_Rerolled));
  }
  if (m_AvgIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("avg")), m_Avg));
  }
  if (m_StddevIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("stddev")), m_Stddev));
  }
  if (m_MinIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("min")), m_Min));
  }
  if (m_MaxIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("max")), m_Max));
  }
  if (m_PopIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("pop")), m_Pop));
  }
  if (m_MedianIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("median")), m_Median));
  }
}

bool RivenStatistic::fromMultiPart(std::shared_ptr<MultipartFormData> multipart,
                                   const utility::string_t &prefix) {
  bool ok = true;
  utility::string_t namePrefix = prefix;
  if (namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) !=
                                   utility::conversions::to_string_t(U("."))) {
    namePrefix += utility::conversions::to_string_t(U("."));
  }

  if (multipart->hasContent(utility::conversions::to_string_t(U("itemType")))) {
    utility::string_t refVal_setItemType;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("itemType"))),
        refVal_setItemType);
    setItemType(refVal_setItemType);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("compatability")))) {
    utility::string_t refVal_setCompatability;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("compatability"))),
        refVal_setCompatability);
    setCompatability(refVal_setCompatability);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("rerolled")))) {
    bool refVal_setRerolled;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("rerolled"))),
        refVal_setRerolled);
    setRerolled(refVal_setRerolled);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("avg")))) {
    float refVal_setAvg;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("avg"))),
        refVal_setAvg);
    setAvg(refVal_setAvg);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("stddev")))) {
    float refVal_setStddev;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("stddev"))),
        refVal_setStddev);
    setStddev(refVal_setStddev);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("min")))) {
    float refVal_setMin;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("min"))),
        refVal_setMin);
    setMin(refVal_setMin);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("max")))) {
    float refVal_setMax;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("max"))),
        refVal_setMax);
    setMax(refVal_setMax);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("pop")))) {
    float refVal_setPop;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("pop"))),
        refVal_setPop);
    setPop(refVal_setPop);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("median")))) {
    float refVal_setMedian;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("median"))),
        refVal_setMedian);
    setMedian(refVal_setMedian);
  }
  return ok;
}

utility::string_t RivenStatistic::getItemType() const { return m_ItemType; }

void RivenStatistic::setItemType(const utility::string_t &value) {
  m_ItemType = value;
  m_ItemTypeIsSet = true;
}

bool RivenStatistic::itemTypeIsSet() const { return m_ItemTypeIsSet; }

void RivenStatistic::unsetItemType() { m_ItemTypeIsSet = false; }
utility::string_t RivenStatistic::getCompatability() const {
  return m_Compatability;
}

void RivenStatistic::setCompatability(const utility::string_t &value) {
  m_Compatability = value;
  m_CompatabilityIsSet = true;
}

bool RivenStatistic::compatabilityIsSet() const { return m_CompatabilityIsSet; }

void RivenStatistic::unsetCompatability() { m_CompatabilityIsSet = false; }
bool RivenStatistic::isRerolled() const { return m_Rerolled; }

void RivenStatistic::setRerolled(bool value) {
  m_Rerolled = value;
  m_RerolledIsSet = true;
}

bool RivenStatistic::rerolledIsSet() const { return m_RerolledIsSet; }

void RivenStatistic::unsetRerolled() { m_RerolledIsSet = false; }
float RivenStatistic::getAvg() const { return m_Avg; }

void RivenStatistic::setAvg(float value) {
  m_Avg = value;
  m_AvgIsSet = true;
}

bool RivenStatistic::avgIsSet() const { return m_AvgIsSet; }

void RivenStatistic::unsetAvg() { m_AvgIsSet = false; }
float RivenStatistic::getStddev() const { return m_Stddev; }

void RivenStatistic::setStddev(float value) {
  m_Stddev = value;
  m_StddevIsSet = true;
}

bool RivenStatistic::stddevIsSet() const { return m_StddevIsSet; }

void RivenStatistic::unsetStddev() { m_StddevIsSet = false; }
float RivenStatistic::getMin() const { return m_Min; }

void RivenStatistic::setMin(float value) {
  m_Min = value;
  m_MinIsSet = true;
}

bool RivenStatistic::minIsSet() const { return m_MinIsSet; }

void RivenStatistic::unsetMin() { m_MinIsSet = false; }
float RivenStatistic::getMax() const { return m_Max; }

void RivenStatistic::setMax(float value) {
  m_Max = value;
  m_MaxIsSet = true;
}

bool RivenStatistic::maxIsSet() const { return m_MaxIsSet; }

void RivenStatistic::unsetMax() { m_MaxIsSet = false; }
float RivenStatistic::getPop() const { return m_Pop; }

void RivenStatistic::setPop(float value) {
  m_Pop = value;
  m_PopIsSet = true;
}

bool RivenStatistic::popIsSet() const { return m_PopIsSet; }

void RivenStatistic::unsetPop() { m_PopIsSet = false; }
float RivenStatistic::getMedian() const { return m_Median; }

void RivenStatistic::setMedian(float value) {
  m_Median = value;
  m_MedianIsSet = true;
}

bool RivenStatistic::medianIsSet() const { return m_MedianIsSet; }

void RivenStatistic::unsetMedian() { m_MedianIsSet = false; }
} // namespace model
} // namespace client
} // namespace openapitools
} // namespace org
