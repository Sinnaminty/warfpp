/**
 * WarframeStat.us API
 * Simple API for data from the game Warframe. [Parser
 * Docs](https://wfcd.github.io/warframe-worldstate-parser/) [Items
 * Types](https://github.com/WFCD/warframe-items/blob/master/index.d.ts)
 *
 * The version of the OpenAPI document: 2.0.8
 * Contact: tobiah@protonmail.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.8.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "CppRestOpenAPIClient/model/Mod.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {

Mod::Mod() {
  m_Name = utility::conversions::to_string_t("");
  m_NameIsSet = false;
  m_UniqueName = utility::conversions::to_string_t("");
  m_UniqueNameIsSet = false;
  m_Description = utility::conversions::to_string_t("");
  m_DescriptionIsSet = false;
  m_Type = utility::conversions::to_string_t("");
  m_TypeIsSet = false;
  m_Tradable = false;
  m_TradableIsSet = false;
  m_Category = utility::conversions::to_string_t("");
  m_CategoryIsSet = false;
  m_ProductCategory = utility::conversions::to_string_t("");
  m_ProductCategoryIsSet = false;
  m_PatchlogsIsSet = false;
  m_ComponentsIsSet = false;
  m_IntroducedIsSet = false;
  m_EstimatedVaultDateIsSet = false;
  m_BaseDrain = 0;
  m_BaseDrainIsSet = false;
  m_CompatName = utility::conversions::to_string_t("");
  m_CompatNameIsSet = false;
  m_FusionLimit = 0;
  m_FusionLimitIsSet = false;
  m_LevelStatsIsSet = false;
  m_PolarityIsSet = false;
  m_Transmutable = false;
  m_TransmutableIsSet = false;
}

Mod::~Mod() {}

void Mod::validate() {
  // TODO: implement validation
}

web::json::value Mod::toJson() const {

  web::json::value val = web::json::value::object();

  if (m_NameIsSet) {
    val[utility::conversions::to_string_t(U("name"))] =
        ModelBase::toJson(m_Name);
  }
  if (m_UniqueNameIsSet) {
    val[utility::conversions::to_string_t(U("uniqueName"))] =
        ModelBase::toJson(m_UniqueName);
  }
  if (m_DescriptionIsSet) {
    val[utility::conversions::to_string_t(U("description"))] =
        ModelBase::toJson(m_Description);
  }
  if (m_TypeIsSet) {
    val[utility::conversions::to_string_t(U("type"))] =
        ModelBase::toJson(m_Type);
  }
  if (m_TradableIsSet) {
    val[utility::conversions::to_string_t(U("tradable"))] =
        ModelBase::toJson(m_Tradable);
  }
  if (m_CategoryIsSet) {
    val[utility::conversions::to_string_t(U("category"))] =
        ModelBase::toJson(m_Category);
  }
  if (m_ProductCategoryIsSet) {
    val[utility::conversions::to_string_t(U("productCategory"))] =
        ModelBase::toJson(m_ProductCategory);
  }
  if (m_PatchlogsIsSet) {
    val[utility::conversions::to_string_t(U("patchlogs"))] =
        ModelBase::toJson(m_Patchlogs);
  }
  if (m_ComponentsIsSet) {
    val[utility::conversions::to_string_t(U("components"))] =
        ModelBase::toJson(m_Components);
  }
  if (m_IntroducedIsSet) {
    val[utility::conversions::to_string_t(U("introduced"))] =
        ModelBase::toJson(m_Introduced);
  }
  if (m_EstimatedVaultDateIsSet) {
    val[utility::conversions::to_string_t(U("estimatedVaultDate"))] =
        ModelBase::toJson(m_EstimatedVaultDate);
  }
  if (m_BaseDrainIsSet) {
    val[utility::conversions::to_string_t(U("baseDrain"))] =
        ModelBase::toJson(m_BaseDrain);
  }
  if (m_CompatNameIsSet) {
    val[utility::conversions::to_string_t(U("compatName"))] =
        ModelBase::toJson(m_CompatName);
  }
  if (m_FusionLimitIsSet) {
    val[utility::conversions::to_string_t(U("fusionLimit"))] =
        ModelBase::toJson(m_FusionLimit);
  }
  if (m_LevelStatsIsSet) {
    val[utility::conversions::to_string_t(U("levelStats"))] =
        ModelBase::toJson(m_LevelStats);
  }
  if (m_PolarityIsSet) {
    val[utility::conversions::to_string_t(U("polarity"))] =
        ModelBase::toJson(m_Polarity);
  }
  if (m_TransmutableIsSet) {
    val[utility::conversions::to_string_t(U("transmutable"))] =
        ModelBase::toJson(m_Transmutable);
  }

  return val;
}

bool Mod::fromJson(const web::json::value &val) {
  bool ok = true;

  if (val.has_field(utility::conversions::to_string_t(U("name")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("name")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setName;
      ok &= ModelBase::fromJson(fieldValue, refVal_setName);
      setName(refVal_setName);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("uniqueName")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("uniqueName")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setUniqueName;
      ok &= ModelBase::fromJson(fieldValue, refVal_setUniqueName);
      setUniqueName(refVal_setUniqueName);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("description")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("description")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setDescription;
      ok &= ModelBase::fromJson(fieldValue, refVal_setDescription);
      setDescription(refVal_setDescription);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("type")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("type")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setType;
      ok &= ModelBase::fromJson(fieldValue, refVal_setType);
      setType(refVal_setType);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("tradable")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("tradable")));
    if (!fieldValue.is_null()) {
      bool refVal_setTradable;
      ok &= ModelBase::fromJson(fieldValue, refVal_setTradable);
      setTradable(refVal_setTradable);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("category")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("category")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setCategory;
      ok &= ModelBase::fromJson(fieldValue, refVal_setCategory);
      setCategory(refVal_setCategory);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("productCategory")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("productCategory")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setProductCategory;
      ok &= ModelBase::fromJson(fieldValue, refVal_setProductCategory);
      setProductCategory(refVal_setProductCategory);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("patchlogs")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("patchlogs")));
    if (!fieldValue.is_null()) {
      std::vector<std::shared_ptr<Patchlog>> refVal_setPatchlogs;
      ok &= ModelBase::fromJson(fieldValue, refVal_setPatchlogs);
      setPatchlogs(refVal_setPatchlogs);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("components")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("components")));
    if (!fieldValue.is_null()) {
      std::vector<std::shared_ptr<ShallowItem>> refVal_setComponents;
      ok &= ModelBase::fromJson(fieldValue, refVal_setComponents);
      setComponents(refVal_setComponents);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("introduced")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("introduced")));
    if (!fieldValue.is_null()) {
      std::shared_ptr<Introduced> refVal_setIntroduced;
      ok &= ModelBase::fromJson(fieldValue, refVal_setIntroduced);
      setIntroduced(refVal_setIntroduced);
    }
  }
  if (val.has_field(
          utility::conversions::to_string_t(U("estimatedVaultDate")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("estimatedVaultDate")));
    if (!fieldValue.is_null()) {
      utility::datetime refVal_setEstimatedVaultDate;
      ok &= ModelBase::fromJson(fieldValue, refVal_setEstimatedVaultDate);
      setEstimatedVaultDate(refVal_setEstimatedVaultDate);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("baseDrain")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("baseDrain")));
    if (!fieldValue.is_null()) {
      int32_t refVal_setBaseDrain;
      ok &= ModelBase::fromJson(fieldValue, refVal_setBaseDrain);
      setBaseDrain(refVal_setBaseDrain);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("compatName")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("compatName")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setCompatName;
      ok &= ModelBase::fromJson(fieldValue, refVal_setCompatName);
      setCompatName(refVal_setCompatName);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("fusionLimit")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("fusionLimit")));
    if (!fieldValue.is_null()) {
      int32_t refVal_setFusionLimit;
      ok &= ModelBase::fromJson(fieldValue, refVal_setFusionLimit);
      setFusionLimit(refVal_setFusionLimit);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("levelStats")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("levelStats")));
    if (!fieldValue.is_null()) {
      std::vector<std::shared_ptr<Mod_allOf_levelStats>> refVal_setLevelStats;
      ok &= ModelBase::fromJson(fieldValue, refVal_setLevelStats);
      setLevelStats(refVal_setLevelStats);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("polarity")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("polarity")));
    if (!fieldValue.is_null()) {
      std::shared_ptr<Polarity> refVal_setPolarity;
      ok &= ModelBase::fromJson(fieldValue, refVal_setPolarity);
      setPolarity(refVal_setPolarity);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("transmutable")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("transmutable")));
    if (!fieldValue.is_null()) {
      bool refVal_setTransmutable;
      ok &= ModelBase::fromJson(fieldValue, refVal_setTransmutable);
      setTransmutable(refVal_setTransmutable);
    }
  }
  return ok;
}

void Mod::toMultipart(std::shared_ptr<MultipartFormData> multipart,
                      const utility::string_t &prefix) const {
  utility::string_t namePrefix = prefix;
  if (namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) !=
                                   utility::conversions::to_string_t(U("."))) {
    namePrefix += utility::conversions::to_string_t(U("."));
  }
  if (m_NameIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("name")), m_Name));
  }
  if (m_UniqueNameIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("uniqueName")),
        m_UniqueName));
  }
  if (m_DescriptionIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("description")),
        m_Description));
  }
  if (m_TypeIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("type")), m_Type));
  }
  if (m_TradableIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("tradable")),
        m_Tradable));
  }
  if (m_CategoryIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("category")),
        m_Category));
  }
  if (m_ProductCategoryIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("productCategory")),
        m_ProductCategory));
  }
  if (m_PatchlogsIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("patchlogs")),
        m_Patchlogs));
  }
  if (m_ComponentsIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("components")),
        m_Components));
  }
  if (m_IntroducedIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("introduced")),
        m_Introduced));
  }
  if (m_EstimatedVaultDateIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("estimatedVaultDate")),
        m_EstimatedVaultDate));
  }
  if (m_BaseDrainIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("baseDrain")),
        m_BaseDrain));
  }
  if (m_CompatNameIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("compatName")),
        m_CompatName));
  }
  if (m_FusionLimitIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("fusionLimit")),
        m_FusionLimit));
  }
  if (m_LevelStatsIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("levelStats")),
        m_LevelStats));
  }
  if (m_PolarityIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("polarity")),
        m_Polarity));
  }
  if (m_TransmutableIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("transmutable")),
        m_Transmutable));
  }
}

bool Mod::fromMultiPart(std::shared_ptr<MultipartFormData> multipart,
                        const utility::string_t &prefix) {
  bool ok = true;
  utility::string_t namePrefix = prefix;
  if (namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) !=
                                   utility::conversions::to_string_t(U("."))) {
    namePrefix += utility::conversions::to_string_t(U("."));
  }

  if (multipart->hasContent(utility::conversions::to_string_t(U("name")))) {
    utility::string_t refVal_setName;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("name"))),
        refVal_setName);
    setName(refVal_setName);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("uniqueName")))) {
    utility::string_t refVal_setUniqueName;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("uniqueName"))),
        refVal_setUniqueName);
    setUniqueName(refVal_setUniqueName);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("description")))) {
    utility::string_t refVal_setDescription;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("description"))),
        refVal_setDescription);
    setDescription(refVal_setDescription);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("type")))) {
    utility::string_t refVal_setType;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("type"))),
        refVal_setType);
    setType(refVal_setType);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("tradable")))) {
    bool refVal_setTradable;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("tradable"))),
        refVal_setTradable);
    setTradable(refVal_setTradable);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("category")))) {
    utility::string_t refVal_setCategory;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("category"))),
        refVal_setCategory);
    setCategory(refVal_setCategory);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("productCategory")))) {
    utility::string_t refVal_setProductCategory;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("productCategory"))),
        refVal_setProductCategory);
    setProductCategory(refVal_setProductCategory);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("patchlogs")))) {
    std::vector<std::shared_ptr<Patchlog>> refVal_setPatchlogs;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("patchlogs"))),
        refVal_setPatchlogs);
    setPatchlogs(refVal_setPatchlogs);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("components")))) {
    std::vector<std::shared_ptr<ShallowItem>> refVal_setComponents;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("components"))),
        refVal_setComponents);
    setComponents(refVal_setComponents);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("introduced")))) {
    std::shared_ptr<Introduced> refVal_setIntroduced;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("introduced"))),
        refVal_setIntroduced);
    setIntroduced(refVal_setIntroduced);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("estimatedVaultDate")))) {
    utility::datetime refVal_setEstimatedVaultDate;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("estimatedVaultDate"))),
        refVal_setEstimatedVaultDate);
    setEstimatedVaultDate(refVal_setEstimatedVaultDate);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("baseDrain")))) {
    int32_t refVal_setBaseDrain;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("baseDrain"))),
        refVal_setBaseDrain);
    setBaseDrain(refVal_setBaseDrain);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("compatName")))) {
    utility::string_t refVal_setCompatName;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("compatName"))),
        refVal_setCompatName);
    setCompatName(refVal_setCompatName);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("fusionLimit")))) {
    int32_t refVal_setFusionLimit;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("fusionLimit"))),
        refVal_setFusionLimit);
    setFusionLimit(refVal_setFusionLimit);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("levelStats")))) {
    std::vector<std::shared_ptr<Mod_allOf_levelStats>> refVal_setLevelStats;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("levelStats"))),
        refVal_setLevelStats);
    setLevelStats(refVal_setLevelStats);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("polarity")))) {
    std::shared_ptr<Polarity> refVal_setPolarity;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("polarity"))),
        refVal_setPolarity);
    setPolarity(refVal_setPolarity);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("transmutable")))) {
    bool refVal_setTransmutable;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("transmutable"))),
        refVal_setTransmutable);
    setTransmutable(refVal_setTransmutable);
  }
  return ok;
}

utility::string_t Mod::getName() const { return m_Name; }

void Mod::setName(const utility::string_t &value) {
  m_Name = value;
  m_NameIsSet = true;
}

bool Mod::nameIsSet() const { return m_NameIsSet; }

void Mod::unsetName() { m_NameIsSet = false; }
utility::string_t Mod::getUniqueName() const { return m_UniqueName; }

void Mod::setUniqueName(const utility::string_t &value) {
  m_UniqueName = value;
  m_UniqueNameIsSet = true;
}

bool Mod::uniqueNameIsSet() const { return m_UniqueNameIsSet; }

void Mod::unsetUniqueName() { m_UniqueNameIsSet = false; }
utility::string_t Mod::getDescription() const { return m_Description; }

void Mod::setDescription(const utility::string_t &value) {
  m_Description = value;
  m_DescriptionIsSet = true;
}

bool Mod::descriptionIsSet() const { return m_DescriptionIsSet; }

void Mod::unsetDescription() { m_DescriptionIsSet = false; }
utility::string_t Mod::getType() const { return m_Type; }

void Mod::setType(const utility::string_t &value) {
  m_Type = value;
  m_TypeIsSet = true;
}

bool Mod::typeIsSet() const { return m_TypeIsSet; }

void Mod::unsetType() { m_TypeIsSet = false; }
bool Mod::isTradable() const { return m_Tradable; }

void Mod::setTradable(bool value) {
  m_Tradable = value;
  m_TradableIsSet = true;
}

bool Mod::tradableIsSet() const { return m_TradableIsSet; }

void Mod::unsetTradable() { m_TradableIsSet = false; }
utility::string_t Mod::getCategory() const { return m_Category; }

void Mod::setCategory(const utility::string_t &value) {
  m_Category = value;
  m_CategoryIsSet = true;
}

bool Mod::categoryIsSet() const { return m_CategoryIsSet; }

void Mod::unsetCategory() { m_CategoryIsSet = false; }
utility::string_t Mod::getProductCategory() const { return m_ProductCategory; }

void Mod::setProductCategory(const utility::string_t &value) {
  m_ProductCategory = value;
  m_ProductCategoryIsSet = true;
}

bool Mod::productCategoryIsSet() const { return m_ProductCategoryIsSet; }

void Mod::unsetProductCategory() { m_ProductCategoryIsSet = false; }
std::vector<std::shared_ptr<Patchlog>> &Mod::getPatchlogs() {
  return m_Patchlogs;
}

void Mod::setPatchlogs(const std::vector<std::shared_ptr<Patchlog>> &value) {
  m_Patchlogs = value;
  m_PatchlogsIsSet = true;
}

bool Mod::patchlogsIsSet() const { return m_PatchlogsIsSet; }

void Mod::unsetPatchlogs() { m_PatchlogsIsSet = false; }
std::vector<std::shared_ptr<ShallowItem>> &Mod::getComponents() {
  return m_Components;
}

void Mod::setComponents(
    const std::vector<std::shared_ptr<ShallowItem>> &value) {
  m_Components = value;
  m_ComponentsIsSet = true;
}

bool Mod::componentsIsSet() const { return m_ComponentsIsSet; }

void Mod::unsetComponents() { m_ComponentsIsSet = false; }
std::shared_ptr<Introduced> Mod::getIntroduced() const { return m_Introduced; }

void Mod::setIntroduced(const std::shared_ptr<Introduced> &value) {
  m_Introduced = value;
  m_IntroducedIsSet = true;
}

bool Mod::introducedIsSet() const { return m_IntroducedIsSet; }

void Mod::unsetIntroduced() { m_IntroducedIsSet = false; }
utility::datetime Mod::getEstimatedVaultDate() const {
  return m_EstimatedVaultDate;
}

void Mod::setEstimatedVaultDate(const utility::datetime &value) {
  m_EstimatedVaultDate = value;
  m_EstimatedVaultDateIsSet = true;
}

bool Mod::estimatedVaultDateIsSet() const { return m_EstimatedVaultDateIsSet; }

void Mod::unsetEstimatedVaultDate() { m_EstimatedVaultDateIsSet = false; }
int32_t Mod::getBaseDrain() const { return m_BaseDrain; }

void Mod::setBaseDrain(int32_t value) {
  m_BaseDrain = value;
  m_BaseDrainIsSet = true;
}

bool Mod::baseDrainIsSet() const { return m_BaseDrainIsSet; }

void Mod::unsetBaseDrain() { m_BaseDrainIsSet = false; }
utility::string_t Mod::getCompatName() const { return m_CompatName; }

void Mod::setCompatName(const utility::string_t &value) {
  m_CompatName = value;
  m_CompatNameIsSet = true;
}

bool Mod::compatNameIsSet() const { return m_CompatNameIsSet; }

void Mod::unsetCompatName() { m_CompatNameIsSet = false; }
int32_t Mod::getFusionLimit() const { return m_FusionLimit; }

void Mod::setFusionLimit(int32_t value) {
  m_FusionLimit = value;
  m_FusionLimitIsSet = true;
}

bool Mod::fusionLimitIsSet() const { return m_FusionLimitIsSet; }

void Mod::unsetFusionLimit() { m_FusionLimitIsSet = false; }
std::vector<std::shared_ptr<Mod_allOf_levelStats>> &Mod::getLevelStats() {
  return m_LevelStats;
}

void Mod::setLevelStats(
    const std::vector<std::shared_ptr<Mod_allOf_levelStats>> &value) {
  m_LevelStats = value;
  m_LevelStatsIsSet = true;
}

bool Mod::levelStatsIsSet() const { return m_LevelStatsIsSet; }

void Mod::unsetLevelStats() { m_LevelStatsIsSet = false; }
std::shared_ptr<Polarity> Mod::getPolarity() const { return m_Polarity; }

void Mod::setPolarity(const std::shared_ptr<Polarity> &value) {
  m_Polarity = value;
  m_PolarityIsSet = true;
}

bool Mod::polarityIsSet() const { return m_PolarityIsSet; }

void Mod::unsetPolarity() { m_PolarityIsSet = false; }
bool Mod::isTransmutable() const { return m_Transmutable; }

void Mod::setTransmutable(bool value) {
  m_Transmutable = value;
  m_TransmutableIsSet = true;
}

bool Mod::transmutableIsSet() const { return m_TransmutableIsSet; }

void Mod::unsetTransmutable() { m_TransmutableIsSet = false; }
} // namespace model
} // namespace client
} // namespace openapitools
} // namespace org
