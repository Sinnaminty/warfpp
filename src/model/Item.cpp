/**
 * WarframeStat.us API
 * Simple API for data from the game Warframe. [Parser
 * Docs](https://wfcd.github.io/warframe-worldstate-parser/) [Items
 * Types](https://github.com/WFCD/warframe-items/blob/master/index.d.ts)
 *
 * The version of the OpenAPI document: 2.0.8
 * Contact: tobiah@protonmail.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.8.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "CppRestOpenAPIClient/model/Item.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {

Item::Item() {
  m_Name = utility::conversions::to_string_t("");
  m_NameIsSet = false;
  m_UniqueName = utility::conversions::to_string_t("");
  m_UniqueNameIsSet = false;
  m_Description = utility::conversions::to_string_t("");
  m_DescriptionIsSet = false;
  m_Type = utility::conversions::to_string_t("");
  m_TypeIsSet = false;
  m_Tradable = false;
  m_TradableIsSet = false;
  m_Category = utility::conversions::to_string_t("");
  m_CategoryIsSet = false;
  m_ProductCategory = utility::conversions::to_string_t("");
  m_ProductCategoryIsSet = false;
  m_PatchlogsIsSet = false;
  m_ComponentsIsSet = false;
  m_IntroducedIsSet = false;
  m_EstimatedVaultDateIsSet = false;
}

Item::~Item() {}

void Item::validate() {
  // TODO: implement validation
}

web::json::value Item::toJson() const {

  web::json::value val = web::json::value::object();

  if (m_NameIsSet) {
    val[utility::conversions::to_string_t(U("name"))] =
        ModelBase::toJson(m_Name);
  }
  if (m_UniqueNameIsSet) {
    val[utility::conversions::to_string_t(U("uniqueName"))] =
        ModelBase::toJson(m_UniqueName);
  }
  if (m_DescriptionIsSet) {
    val[utility::conversions::to_string_t(U("description"))] =
        ModelBase::toJson(m_Description);
  }
  if (m_TypeIsSet) {
    val[utility::conversions::to_string_t(U("type"))] =
        ModelBase::toJson(m_Type);
  }
  if (m_TradableIsSet) {
    val[utility::conversions::to_string_t(U("tradable"))] =
        ModelBase::toJson(m_Tradable);
  }
  if (m_CategoryIsSet) {
    val[utility::conversions::to_string_t(U("category"))] =
        ModelBase::toJson(m_Category);
  }
  if (m_ProductCategoryIsSet) {
    val[utility::conversions::to_string_t(U("productCategory"))] =
        ModelBase::toJson(m_ProductCategory);
  }
  if (m_PatchlogsIsSet) {
    val[utility::conversions::to_string_t(U("patchlogs"))] =
        ModelBase::toJson(m_Patchlogs);
  }
  if (m_ComponentsIsSet) {
    val[utility::conversions::to_string_t(U("components"))] =
        ModelBase::toJson(m_Components);
  }
  if (m_IntroducedIsSet) {
    val[utility::conversions::to_string_t(U("introduced"))] =
        ModelBase::toJson(m_Introduced);
  }
  if (m_EstimatedVaultDateIsSet) {
    val[utility::conversions::to_string_t(U("estimatedVaultDate"))] =
        ModelBase::toJson(m_EstimatedVaultDate);
  }

  return val;
}

bool Item::fromJson(const web::json::value &val) {
  bool ok = true;

  if (val.has_field(utility::conversions::to_string_t(U("name")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("name")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setName;
      ok &= ModelBase::fromJson(fieldValue, refVal_setName);
      setName(refVal_setName);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("uniqueName")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("uniqueName")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setUniqueName;
      ok &= ModelBase::fromJson(fieldValue, refVal_setUniqueName);
      setUniqueName(refVal_setUniqueName);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("description")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("description")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setDescription;
      ok &= ModelBase::fromJson(fieldValue, refVal_setDescription);
      setDescription(refVal_setDescription);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("type")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("type")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setType;
      ok &= ModelBase::fromJson(fieldValue, refVal_setType);
      setType(refVal_setType);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("tradable")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("tradable")));
    if (!fieldValue.is_null()) {
      bool refVal_setTradable;
      ok &= ModelBase::fromJson(fieldValue, refVal_setTradable);
      setTradable(refVal_setTradable);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("category")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("category")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setCategory;
      ok &= ModelBase::fromJson(fieldValue, refVal_setCategory);
      setCategory(refVal_setCategory);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("productCategory")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("productCategory")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setProductCategory;
      ok &= ModelBase::fromJson(fieldValue, refVal_setProductCategory);
      setProductCategory(refVal_setProductCategory);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("patchlogs")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("patchlogs")));
    if (!fieldValue.is_null()) {
      std::vector<std::shared_ptr<Patchlog>> refVal_setPatchlogs;
      ok &= ModelBase::fromJson(fieldValue, refVal_setPatchlogs);
      setPatchlogs(refVal_setPatchlogs);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("components")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("components")));
    if (!fieldValue.is_null()) {
      std::vector<std::shared_ptr<ShallowItem>> refVal_setComponents;
      ok &= ModelBase::fromJson(fieldValue, refVal_setComponents);
      setComponents(refVal_setComponents);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("introduced")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("introduced")));
    if (!fieldValue.is_null()) {
      std::shared_ptr<Introduced> refVal_setIntroduced;
      ok &= ModelBase::fromJson(fieldValue, refVal_setIntroduced);
      setIntroduced(refVal_setIntroduced);
    }
  }
  if (val.has_field(
          utility::conversions::to_string_t(U("estimatedVaultDate")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("estimatedVaultDate")));
    if (!fieldValue.is_null()) {
      utility::datetime refVal_setEstimatedVaultDate;
      ok &= ModelBase::fromJson(fieldValue, refVal_setEstimatedVaultDate);
      setEstimatedVaultDate(refVal_setEstimatedVaultDate);
    }
  }
  return ok;
}

void Item::toMultipart(std::shared_ptr<MultipartFormData> multipart,
                       const utility::string_t &prefix) const {
  utility::string_t namePrefix = prefix;
  if (namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) !=
                                   utility::conversions::to_string_t(U("."))) {
    namePrefix += utility::conversions::to_string_t(U("."));
  }
  if (m_NameIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("name")), m_Name));
  }
  if (m_UniqueNameIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("uniqueName")),
        m_UniqueName));
  }
  if (m_DescriptionIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("description")),
        m_Description));
  }
  if (m_TypeIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("type")), m_Type));
  }
  if (m_TradableIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("tradable")),
        m_Tradable));
  }
  if (m_CategoryIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("category")),
        m_Category));
  }
  if (m_ProductCategoryIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("productCategory")),
        m_ProductCategory));
  }
  if (m_PatchlogsIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("patchlogs")),
        m_Patchlogs));
  }
  if (m_ComponentsIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("components")),
        m_Components));
  }
  if (m_IntroducedIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("introduced")),
        m_Introduced));
  }
  if (m_EstimatedVaultDateIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("estimatedVaultDate")),
        m_EstimatedVaultDate));
  }
}

bool Item::fromMultiPart(std::shared_ptr<MultipartFormData> multipart,
                         const utility::string_t &prefix) {
  bool ok = true;
  utility::string_t namePrefix = prefix;
  if (namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) !=
                                   utility::conversions::to_string_t(U("."))) {
    namePrefix += utility::conversions::to_string_t(U("."));
  }

  if (multipart->hasContent(utility::conversions::to_string_t(U("name")))) {
    utility::string_t refVal_setName;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("name"))),
        refVal_setName);
    setName(refVal_setName);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("uniqueName")))) {
    utility::string_t refVal_setUniqueName;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("uniqueName"))),
        refVal_setUniqueName);
    setUniqueName(refVal_setUniqueName);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("description")))) {
    utility::string_t refVal_setDescription;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("description"))),
        refVal_setDescription);
    setDescription(refVal_setDescription);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("type")))) {
    utility::string_t refVal_setType;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("type"))),
        refVal_setType);
    setType(refVal_setType);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("tradable")))) {
    bool refVal_setTradable;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("tradable"))),
        refVal_setTradable);
    setTradable(refVal_setTradable);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("category")))) {
    utility::string_t refVal_setCategory;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("category"))),
        refVal_setCategory);
    setCategory(refVal_setCategory);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("productCategory")))) {
    utility::string_t refVal_setProductCategory;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("productCategory"))),
        refVal_setProductCategory);
    setProductCategory(refVal_setProductCategory);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("patchlogs")))) {
    std::vector<std::shared_ptr<Patchlog>> refVal_setPatchlogs;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("patchlogs"))),
        refVal_setPatchlogs);
    setPatchlogs(refVal_setPatchlogs);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("components")))) {
    std::vector<std::shared_ptr<ShallowItem>> refVal_setComponents;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("components"))),
        refVal_setComponents);
    setComponents(refVal_setComponents);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("introduced")))) {
    std::shared_ptr<Introduced> refVal_setIntroduced;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("introduced"))),
        refVal_setIntroduced);
    setIntroduced(refVal_setIntroduced);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("estimatedVaultDate")))) {
    utility::datetime refVal_setEstimatedVaultDate;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("estimatedVaultDate"))),
        refVal_setEstimatedVaultDate);
    setEstimatedVaultDate(refVal_setEstimatedVaultDate);
  }
  return ok;
}

utility::string_t Item::getName() const { return m_Name; }

void Item::setName(const utility::string_t &value) {
  m_Name = value;
  m_NameIsSet = true;
}

bool Item::nameIsSet() const { return m_NameIsSet; }

void Item::unsetName() { m_NameIsSet = false; }
utility::string_t Item::getUniqueName() const { return m_UniqueName; }

void Item::setUniqueName(const utility::string_t &value) {
  m_UniqueName = value;
  m_UniqueNameIsSet = true;
}

bool Item::uniqueNameIsSet() const { return m_UniqueNameIsSet; }

void Item::unsetUniqueName() { m_UniqueNameIsSet = false; }
utility::string_t Item::getDescription() const { return m_Description; }

void Item::setDescription(const utility::string_t &value) {
  m_Description = value;
  m_DescriptionIsSet = true;
}

bool Item::descriptionIsSet() const { return m_DescriptionIsSet; }

void Item::unsetDescription() { m_DescriptionIsSet = false; }
utility::string_t Item::getType() const { return m_Type; }

void Item::setType(const utility::string_t &value) {
  m_Type = value;
  m_TypeIsSet = true;
}

bool Item::typeIsSet() const { return m_TypeIsSet; }

void Item::unsetType() { m_TypeIsSet = false; }
bool Item::isTradable() const { return m_Tradable; }

void Item::setTradable(bool value) {
  m_Tradable = value;
  m_TradableIsSet = true;
}

bool Item::tradableIsSet() const { return m_TradableIsSet; }

void Item::unsetTradable() { m_TradableIsSet = false; }
utility::string_t Item::getCategory() const { return m_Category; }

void Item::setCategory(const utility::string_t &value) {
  m_Category = value;
  m_CategoryIsSet = true;
}

bool Item::categoryIsSet() const { return m_CategoryIsSet; }

void Item::unsetCategory() { m_CategoryIsSet = false; }
utility::string_t Item::getProductCategory() const { return m_ProductCategory; }

void Item::setProductCategory(const utility::string_t &value) {
  m_ProductCategory = value;
  m_ProductCategoryIsSet = true;
}

bool Item::productCategoryIsSet() const { return m_ProductCategoryIsSet; }

void Item::unsetProductCategory() { m_ProductCategoryIsSet = false; }
std::vector<std::shared_ptr<Patchlog>> &Item::getPatchlogs() {
  return m_Patchlogs;
}

void Item::setPatchlogs(const std::vector<std::shared_ptr<Patchlog>> &value) {
  m_Patchlogs = value;
  m_PatchlogsIsSet = true;
}

bool Item::patchlogsIsSet() const { return m_PatchlogsIsSet; }

void Item::unsetPatchlogs() { m_PatchlogsIsSet = false; }
std::vector<std::shared_ptr<ShallowItem>> &Item::getComponents() {
  return m_Components;
}

void Item::setComponents(
    const std::vector<std::shared_ptr<ShallowItem>> &value) {
  m_Components = value;
  m_ComponentsIsSet = true;
}

bool Item::componentsIsSet() const { return m_ComponentsIsSet; }

void Item::unsetComponents() { m_ComponentsIsSet = false; }
std::shared_ptr<Introduced> Item::getIntroduced() const { return m_Introduced; }

void Item::setIntroduced(const std::shared_ptr<Introduced> &value) {
  m_Introduced = value;
  m_IntroducedIsSet = true;
}

bool Item::introducedIsSet() const { return m_IntroducedIsSet; }

void Item::unsetIntroduced() { m_IntroducedIsSet = false; }
utility::datetime Item::getEstimatedVaultDate() const {
  return m_EstimatedVaultDate;
}

void Item::setEstimatedVaultDate(const utility::datetime &value) {
  m_EstimatedVaultDate = value;
  m_EstimatedVaultDateIsSet = true;
}

bool Item::estimatedVaultDateIsSet() const { return m_EstimatedVaultDateIsSet; }

void Item::unsetEstimatedVaultDate() { m_EstimatedVaultDateIsSet = false; }
} // namespace model
} // namespace client
} // namespace openapitools
} // namespace org
