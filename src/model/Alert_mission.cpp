/**
 * WarframeStat.us API
 * Simple API for data from the game Warframe. [Parser
 * Docs](https://wfcd.github.io/warframe-worldstate-parser/) [Items
 * Types](https://github.com/WFCD/warframe-items/blob/master/index.d.ts)
 *
 * The version of the OpenAPI document: 2.0.8
 * Contact: tobiah@protonmail.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.8.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "CppRestOpenAPIClient/model/Alert_mission.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {

Alert_mission::Alert_mission() {
  m_RewardIsSet = false;
  m_Node = utility::conversions::to_string_t("");
  m_NodeIsSet = false;
  m_NodeKey = utility::conversions::to_string_t("");
  m_NodeKeyIsSet = false;
  m_FactionIsSet = false;
  m_FactionKeyIsSet = false;
  m_MaxEnemyLevel = 0.0;
  m_MaxEnemyLevelIsSet = false;
  m_MinEnemyLevel = 0.0;
  m_MinEnemyLevelIsSet = false;
  m_MaxWaveNum = 0.0;
  m_MaxWaveNumIsSet = false;
  m_TypeIsSet = false;
  m_TypeKeyIsSet = false;
  m_Nightmare = false;
  m_NightmareIsSet = false;
  m_ArchwingRequired = false;
  m_ArchwingRequiredIsSet = false;
  m_IsSharkwing = false;
  m_IsSharkwingIsSet = false;
  m_EnemySpec = utility::conversions::to_string_t("");
  m_EnemySpecIsSet = false;
  m_LevelOverride = utility::conversions::to_string_t("");
  m_LevelOverrideIsSet = false;
  m_AdvancedSpawnersIsSet = false;
  m_RequiredItemsIsSet = false;
  m_ConsumeRequiredItems = false;
  m_ConsumeRequiredItemsIsSet = false;
  m_LeadersAlwaysAllowed = false;
  m_LeadersAlwaysAllowedIsSet = false;
  m_LevelAurasIsSet = false;
  m_Description = utility::conversions::to_string_t("");
  m_DescriptionIsSet = false;
}

Alert_mission::~Alert_mission() {}

void Alert_mission::validate() {
  // TODO: implement validation
}

web::json::value Alert_mission::toJson() const {

  web::json::value val = web::json::value::object();

  if (m_RewardIsSet) {
    val[utility::conversions::to_string_t(U("reward"))] =
        ModelBase::toJson(m_Reward);
  }
  if (m_NodeIsSet) {
    val[utility::conversions::to_string_t(U("node"))] =
        ModelBase::toJson(m_Node);
  }
  if (m_NodeKeyIsSet) {
    val[utility::conversions::to_string_t(U("nodeKey"))] =
        ModelBase::toJson(m_NodeKey);
  }
  if (m_FactionIsSet) {
    val[utility::conversions::to_string_t(U("faction"))] =
        ModelBase::toJson(m_Faction);
  }
  if (m_FactionKeyIsSet) {
    val[utility::conversions::to_string_t(U("factionKey"))] =
        ModelBase::toJson(m_FactionKey);
  }
  if (m_MaxEnemyLevelIsSet) {
    val[utility::conversions::to_string_t(U("maxEnemyLevel"))] =
        ModelBase::toJson(m_MaxEnemyLevel);
  }
  if (m_MinEnemyLevelIsSet) {
    val[utility::conversions::to_string_t(U("minEnemyLevel"))] =
        ModelBase::toJson(m_MinEnemyLevel);
  }
  if (m_MaxWaveNumIsSet) {
    val[utility::conversions::to_string_t(U("maxWaveNum"))] =
        ModelBase::toJson(m_MaxWaveNum);
  }
  if (m_TypeIsSet) {
    val[utility::conversions::to_string_t(U("type"))] =
        ModelBase::toJson(m_Type);
  }
  if (m_TypeKeyIsSet) {
    val[utility::conversions::to_string_t(U("typeKey"))] =
        ModelBase::toJson(m_TypeKey);
  }
  if (m_NightmareIsSet) {
    val[utility::conversions::to_string_t(U("nightmare"))] =
        ModelBase::toJson(m_Nightmare);
  }
  if (m_ArchwingRequiredIsSet) {
    val[utility::conversions::to_string_t(U("archwingRequired"))] =
        ModelBase::toJson(m_ArchwingRequired);
  }
  if (m_IsSharkwingIsSet) {
    val[utility::conversions::to_string_t(U("isSharkwing"))] =
        ModelBase::toJson(m_IsSharkwing);
  }
  if (m_EnemySpecIsSet) {
    val[utility::conversions::to_string_t(U("enemySpec"))] =
        ModelBase::toJson(m_EnemySpec);
  }
  if (m_LevelOverrideIsSet) {
    val[utility::conversions::to_string_t(U("levelOverride"))] =
        ModelBase::toJson(m_LevelOverride);
  }
  if (m_AdvancedSpawnersIsSet) {
    val[utility::conversions::to_string_t(U("advancedSpawners"))] =
        ModelBase::toJson(m_AdvancedSpawners);
  }
  if (m_RequiredItemsIsSet) {
    val[utility::conversions::to_string_t(U("requiredItems"))] =
        ModelBase::toJson(m_RequiredItems);
  }
  if (m_ConsumeRequiredItemsIsSet) {
    val[utility::conversions::to_string_t(U("consumeRequiredItems"))] =
        ModelBase::toJson(m_ConsumeRequiredItems);
  }
  if (m_LeadersAlwaysAllowedIsSet) {
    val[utility::conversions::to_string_t(U("leadersAlwaysAllowed"))] =
        ModelBase::toJson(m_LeadersAlwaysAllowed);
  }
  if (m_LevelAurasIsSet) {
    val[utility::conversions::to_string_t(U("levelAuras"))] =
        ModelBase::toJson(m_LevelAuras);
  }
  if (m_DescriptionIsSet) {
    val[utility::conversions::to_string_t(U("description"))] =
        ModelBase::toJson(m_Description);
  }

  return val;
}

bool Alert_mission::fromJson(const web::json::value &val) {
  bool ok = true;

  if (val.has_field(utility::conversions::to_string_t(U("reward")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("reward")));
    if (!fieldValue.is_null()) {
      std::shared_ptr<Reward> refVal_setReward;
      ok &= ModelBase::fromJson(fieldValue, refVal_setReward);
      setReward(refVal_setReward);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("node")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("node")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setNode;
      ok &= ModelBase::fromJson(fieldValue, refVal_setNode);
      setNode(refVal_setNode);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("nodeKey")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("nodeKey")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setNodeKey;
      ok &= ModelBase::fromJson(fieldValue, refVal_setNodeKey);
      setNodeKey(refVal_setNodeKey);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("faction")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("faction")));
    if (!fieldValue.is_null()) {
      std::shared_ptr<Faction> refVal_setFaction;
      ok &= ModelBase::fromJson(fieldValue, refVal_setFaction);
      setFaction(refVal_setFaction);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("factionKey")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("factionKey")));
    if (!fieldValue.is_null()) {
      std::shared_ptr<Faction> refVal_setFactionKey;
      ok &= ModelBase::fromJson(fieldValue, refVal_setFactionKey);
      setFactionKey(refVal_setFactionKey);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("maxEnemyLevel")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("maxEnemyLevel")));
    if (!fieldValue.is_null()) {
      double refVal_setMaxEnemyLevel;
      ok &= ModelBase::fromJson(fieldValue, refVal_setMaxEnemyLevel);
      setMaxEnemyLevel(refVal_setMaxEnemyLevel);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("minEnemyLevel")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("minEnemyLevel")));
    if (!fieldValue.is_null()) {
      double refVal_setMinEnemyLevel;
      ok &= ModelBase::fromJson(fieldValue, refVal_setMinEnemyLevel);
      setMinEnemyLevel(refVal_setMinEnemyLevel);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("maxWaveNum")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("maxWaveNum")));
    if (!fieldValue.is_null()) {
      double refVal_setMaxWaveNum;
      ok &= ModelBase::fromJson(fieldValue, refVal_setMaxWaveNum);
      setMaxWaveNum(refVal_setMaxWaveNum);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("type")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("type")));
    if (!fieldValue.is_null()) {
      std::shared_ptr<MissionType> refVal_setType;
      ok &= ModelBase::fromJson(fieldValue, refVal_setType);
      setType(refVal_setType);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("typeKey")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("typeKey")));
    if (!fieldValue.is_null()) {
      std::shared_ptr<MissionType> refVal_setTypeKey;
      ok &= ModelBase::fromJson(fieldValue, refVal_setTypeKey);
      setTypeKey(refVal_setTypeKey);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("nightmare")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("nightmare")));
    if (!fieldValue.is_null()) {
      bool refVal_setNightmare;
      ok &= ModelBase::fromJson(fieldValue, refVal_setNightmare);
      setNightmare(refVal_setNightmare);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("archwingRequired")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("archwingRequired")));
    if (!fieldValue.is_null()) {
      bool refVal_setArchwingRequired;
      ok &= ModelBase::fromJson(fieldValue, refVal_setArchwingRequired);
      setArchwingRequired(refVal_setArchwingRequired);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("isSharkwing")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("isSharkwing")));
    if (!fieldValue.is_null()) {
      bool refVal_setIsSharkwing;
      ok &= ModelBase::fromJson(fieldValue, refVal_setIsSharkwing);
      setIsSharkwing(refVal_setIsSharkwing);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("enemySpec")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("enemySpec")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setEnemySpec;
      ok &= ModelBase::fromJson(fieldValue, refVal_setEnemySpec);
      setEnemySpec(refVal_setEnemySpec);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("levelOverride")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("levelOverride")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setLevelOverride;
      ok &= ModelBase::fromJson(fieldValue, refVal_setLevelOverride);
      setLevelOverride(refVal_setLevelOverride);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("advancedSpawners")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("advancedSpawners")));
    if (!fieldValue.is_null()) {
      std::vector<utility::string_t> refVal_setAdvancedSpawners;
      ok &= ModelBase::fromJson(fieldValue, refVal_setAdvancedSpawners);
      setAdvancedSpawners(refVal_setAdvancedSpawners);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("requiredItems")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("requiredItems")));
    if (!fieldValue.is_null()) {
      std::vector<utility::string_t> refVal_setRequiredItems;
      ok &= ModelBase::fromJson(fieldValue, refVal_setRequiredItems);
      setRequiredItems(refVal_setRequiredItems);
    }
  }
  if (val.has_field(
          utility::conversions::to_string_t(U("consumeRequiredItems")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("consumeRequiredItems")));
    if (!fieldValue.is_null()) {
      bool refVal_setConsumeRequiredItems;
      ok &= ModelBase::fromJson(fieldValue, refVal_setConsumeRequiredItems);
      setConsumeRequiredItems(refVal_setConsumeRequiredItems);
    }
  }
  if (val.has_field(
          utility::conversions::to_string_t(U("leadersAlwaysAllowed")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("leadersAlwaysAllowed")));
    if (!fieldValue.is_null()) {
      bool refVal_setLeadersAlwaysAllowed;
      ok &= ModelBase::fromJson(fieldValue, refVal_setLeadersAlwaysAllowed);
      setLeadersAlwaysAllowed(refVal_setLeadersAlwaysAllowed);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("levelAuras")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("levelAuras")));
    if (!fieldValue.is_null()) {
      std::vector<utility::string_t> refVal_setLevelAuras;
      ok &= ModelBase::fromJson(fieldValue, refVal_setLevelAuras);
      setLevelAuras(refVal_setLevelAuras);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("description")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("description")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setDescription;
      ok &= ModelBase::fromJson(fieldValue, refVal_setDescription);
      setDescription(refVal_setDescription);
    }
  }
  return ok;
}

void Alert_mission::toMultipart(std::shared_ptr<MultipartFormData> multipart,
                                const utility::string_t &prefix) const {
  utility::string_t namePrefix = prefix;
  if (namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) !=
                                   utility::conversions::to_string_t(U("."))) {
    namePrefix += utility::conversions::to_string_t(U("."));
  }
  if (m_RewardIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("reward")), m_Reward));
  }
  if (m_NodeIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("node")), m_Node));
  }
  if (m_NodeKeyIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("nodeKey")),
        m_NodeKey));
  }
  if (m_FactionIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("faction")),
        m_Faction));
  }
  if (m_FactionKeyIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("factionKey")),
        m_FactionKey));
  }
  if (m_MaxEnemyLevelIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("maxEnemyLevel")),
        m_MaxEnemyLevel));
  }
  if (m_MinEnemyLevelIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("minEnemyLevel")),
        m_MinEnemyLevel));
  }
  if (m_MaxWaveNumIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("maxWaveNum")),
        m_MaxWaveNum));
  }
  if (m_TypeIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("type")), m_Type));
  }
  if (m_TypeKeyIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("typeKey")),
        m_TypeKey));
  }
  if (m_NightmareIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("nightmare")),
        m_Nightmare));
  }
  if (m_ArchwingRequiredIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("archwingRequired")),
        m_ArchwingRequired));
  }
  if (m_IsSharkwingIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("isSharkwing")),
        m_IsSharkwing));
  }
  if (m_EnemySpecIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("enemySpec")),
        m_EnemySpec));
  }
  if (m_LevelOverrideIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("levelOverride")),
        m_LevelOverride));
  }
  if (m_AdvancedSpawnersIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("advancedSpawners")),
        m_AdvancedSpawners));
  }
  if (m_RequiredItemsIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("requiredItems")),
        m_RequiredItems));
  }
  if (m_ConsumeRequiredItemsIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix +
            utility::conversions::to_string_t(U("consumeRequiredItems")),
        m_ConsumeRequiredItems));
  }
  if (m_LeadersAlwaysAllowedIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix +
            utility::conversions::to_string_t(U("leadersAlwaysAllowed")),
        m_LeadersAlwaysAllowed));
  }
  if (m_LevelAurasIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("levelAuras")),
        m_LevelAuras));
  }
  if (m_DescriptionIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("description")),
        m_Description));
  }
}

bool Alert_mission::fromMultiPart(std::shared_ptr<MultipartFormData> multipart,
                                  const utility::string_t &prefix) {
  bool ok = true;
  utility::string_t namePrefix = prefix;
  if (namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) !=
                                   utility::conversions::to_string_t(U("."))) {
    namePrefix += utility::conversions::to_string_t(U("."));
  }

  if (multipart->hasContent(utility::conversions::to_string_t(U("reward")))) {
    std::shared_ptr<Reward> refVal_setReward;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("reward"))),
        refVal_setReward);
    setReward(refVal_setReward);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("node")))) {
    utility::string_t refVal_setNode;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("node"))),
        refVal_setNode);
    setNode(refVal_setNode);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("nodeKey")))) {
    utility::string_t refVal_setNodeKey;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("nodeKey"))),
        refVal_setNodeKey);
    setNodeKey(refVal_setNodeKey);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("faction")))) {
    std::shared_ptr<Faction> refVal_setFaction;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("faction"))),
        refVal_setFaction);
    setFaction(refVal_setFaction);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("factionKey")))) {
    std::shared_ptr<Faction> refVal_setFactionKey;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("factionKey"))),
        refVal_setFactionKey);
    setFactionKey(refVal_setFactionKey);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("maxEnemyLevel")))) {
    double refVal_setMaxEnemyLevel;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("maxEnemyLevel"))),
        refVal_setMaxEnemyLevel);
    setMaxEnemyLevel(refVal_setMaxEnemyLevel);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("minEnemyLevel")))) {
    double refVal_setMinEnemyLevel;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("minEnemyLevel"))),
        refVal_setMinEnemyLevel);
    setMinEnemyLevel(refVal_setMinEnemyLevel);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("maxWaveNum")))) {
    double refVal_setMaxWaveNum;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("maxWaveNum"))),
        refVal_setMaxWaveNum);
    setMaxWaveNum(refVal_setMaxWaveNum);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("type")))) {
    std::shared_ptr<MissionType> refVal_setType;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("type"))),
        refVal_setType);
    setType(refVal_setType);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("typeKey")))) {
    std::shared_ptr<MissionType> refVal_setTypeKey;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("typeKey"))),
        refVal_setTypeKey);
    setTypeKey(refVal_setTypeKey);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("nightmare")))) {
    bool refVal_setNightmare;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("nightmare"))),
        refVal_setNightmare);
    setNightmare(refVal_setNightmare);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("archwingRequired")))) {
    bool refVal_setArchwingRequired;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("archwingRequired"))),
        refVal_setArchwingRequired);
    setArchwingRequired(refVal_setArchwingRequired);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("isSharkwing")))) {
    bool refVal_setIsSharkwing;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("isSharkwing"))),
        refVal_setIsSharkwing);
    setIsSharkwing(refVal_setIsSharkwing);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("enemySpec")))) {
    utility::string_t refVal_setEnemySpec;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("enemySpec"))),
        refVal_setEnemySpec);
    setEnemySpec(refVal_setEnemySpec);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("levelOverride")))) {
    utility::string_t refVal_setLevelOverride;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("levelOverride"))),
        refVal_setLevelOverride);
    setLevelOverride(refVal_setLevelOverride);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("advancedSpawners")))) {
    std::vector<utility::string_t> refVal_setAdvancedSpawners;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("advancedSpawners"))),
        refVal_setAdvancedSpawners);
    setAdvancedSpawners(refVal_setAdvancedSpawners);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("requiredItems")))) {
    std::vector<utility::string_t> refVal_setRequiredItems;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("requiredItems"))),
        refVal_setRequiredItems);
    setRequiredItems(refVal_setRequiredItems);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("consumeRequiredItems")))) {
    bool refVal_setConsumeRequiredItems;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("consumeRequiredItems"))),
        refVal_setConsumeRequiredItems);
    setConsumeRequiredItems(refVal_setConsumeRequiredItems);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("leadersAlwaysAllowed")))) {
    bool refVal_setLeadersAlwaysAllowed;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("leadersAlwaysAllowed"))),
        refVal_setLeadersAlwaysAllowed);
    setLeadersAlwaysAllowed(refVal_setLeadersAlwaysAllowed);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("levelAuras")))) {
    std::vector<utility::string_t> refVal_setLevelAuras;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("levelAuras"))),
        refVal_setLevelAuras);
    setLevelAuras(refVal_setLevelAuras);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("description")))) {
    utility::string_t refVal_setDescription;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("description"))),
        refVal_setDescription);
    setDescription(refVal_setDescription);
  }
  return ok;
}

std::shared_ptr<Reward> Alert_mission::getReward() const { return m_Reward; }

void Alert_mission::setReward(const std::shared_ptr<Reward> &value) {
  m_Reward = value;
  m_RewardIsSet = true;
}

bool Alert_mission::rewardIsSet() const { return m_RewardIsSet; }

void Alert_mission::unsetReward() { m_RewardIsSet = false; }
utility::string_t Alert_mission::getNode() const { return m_Node; }

void Alert_mission::setNode(const utility::string_t &value) {
  m_Node = value;
  m_NodeIsSet = true;
}

bool Alert_mission::nodeIsSet() const { return m_NodeIsSet; }

void Alert_mission::unsetNode() { m_NodeIsSet = false; }
utility::string_t Alert_mission::getNodeKey() const { return m_NodeKey; }

void Alert_mission::setNodeKey(const utility::string_t &value) {
  m_NodeKey = value;
  m_NodeKeyIsSet = true;
}

bool Alert_mission::nodeKeyIsSet() const { return m_NodeKeyIsSet; }

void Alert_mission::unsetNodeKey() { m_NodeKeyIsSet = false; }
std::shared_ptr<Faction> Alert_mission::getFaction() const { return m_Faction; }

void Alert_mission::setFaction(const std::shared_ptr<Faction> &value) {
  m_Faction = value;
  m_FactionIsSet = true;
}

bool Alert_mission::factionIsSet() const { return m_FactionIsSet; }

void Alert_mission::unsetFaction() { m_FactionIsSet = false; }
std::shared_ptr<Faction> Alert_mission::getFactionKey() const {
  return m_FactionKey;
}

void Alert_mission::setFactionKey(const std::shared_ptr<Faction> &value) {
  m_FactionKey = value;
  m_FactionKeyIsSet = true;
}

bool Alert_mission::factionKeyIsSet() const { return m_FactionKeyIsSet; }

void Alert_mission::unsetFactionKey() { m_FactionKeyIsSet = false; }
double Alert_mission::getMaxEnemyLevel() const { return m_MaxEnemyLevel; }

void Alert_mission::setMaxEnemyLevel(double value) {
  m_MaxEnemyLevel = value;
  m_MaxEnemyLevelIsSet = true;
}

bool Alert_mission::maxEnemyLevelIsSet() const { return m_MaxEnemyLevelIsSet; }

void Alert_mission::unsetMaxEnemyLevel() { m_MaxEnemyLevelIsSet = false; }
double Alert_mission::getMinEnemyLevel() const { return m_MinEnemyLevel; }

void Alert_mission::setMinEnemyLevel(double value) {
  m_MinEnemyLevel = value;
  m_MinEnemyLevelIsSet = true;
}

bool Alert_mission::minEnemyLevelIsSet() const { return m_MinEnemyLevelIsSet; }

void Alert_mission::unsetMinEnemyLevel() { m_MinEnemyLevelIsSet = false; }
double Alert_mission::getMaxWaveNum() const { return m_MaxWaveNum; }

void Alert_mission::setMaxWaveNum(double value) {
  m_MaxWaveNum = value;
  m_MaxWaveNumIsSet = true;
}

bool Alert_mission::maxWaveNumIsSet() const { return m_MaxWaveNumIsSet; }

void Alert_mission::unsetMaxWaveNum() { m_MaxWaveNumIsSet = false; }
std::shared_ptr<MissionType> Alert_mission::getType() const { return m_Type; }

void Alert_mission::setType(const std::shared_ptr<MissionType> &value) {
  m_Type = value;
  m_TypeIsSet = true;
}

bool Alert_mission::typeIsSet() const { return m_TypeIsSet; }

void Alert_mission::unsetType() { m_TypeIsSet = false; }
std::shared_ptr<MissionType> Alert_mission::getTypeKey() const {
  return m_TypeKey;
}

void Alert_mission::setTypeKey(const std::shared_ptr<MissionType> &value) {
  m_TypeKey = value;
  m_TypeKeyIsSet = true;
}

bool Alert_mission::typeKeyIsSet() const { return m_TypeKeyIsSet; }

void Alert_mission::unsetTypeKey() { m_TypeKeyIsSet = false; }
bool Alert_mission::isNightmare() const { return m_Nightmare; }

void Alert_mission::setNightmare(bool value) {
  m_Nightmare = value;
  m_NightmareIsSet = true;
}

bool Alert_mission::nightmareIsSet() const { return m_NightmareIsSet; }

void Alert_mission::unsetNightmare() { m_NightmareIsSet = false; }
bool Alert_mission::isArchwingRequired() const { return m_ArchwingRequired; }

void Alert_mission::setArchwingRequired(bool value) {
  m_ArchwingRequired = value;
  m_ArchwingRequiredIsSet = true;
}

bool Alert_mission::archwingRequiredIsSet() const {
  return m_ArchwingRequiredIsSet;
}

void Alert_mission::unsetArchwingRequired() { m_ArchwingRequiredIsSet = false; }
bool Alert_mission::isIsSharkwing() const { return m_IsSharkwing; }

void Alert_mission::setIsSharkwing(bool value) {
  m_IsSharkwing = value;
  m_IsSharkwingIsSet = true;
}

bool Alert_mission::isSharkwingIsSet() const { return m_IsSharkwingIsSet; }

void Alert_mission::unsetIsSharkwing() { m_IsSharkwingIsSet = false; }
utility::string_t Alert_mission::getEnemySpec() const { return m_EnemySpec; }

void Alert_mission::setEnemySpec(const utility::string_t &value) {
  m_EnemySpec = value;
  m_EnemySpecIsSet = true;
}

bool Alert_mission::enemySpecIsSet() const { return m_EnemySpecIsSet; }

void Alert_mission::unsetEnemySpec() { m_EnemySpecIsSet = false; }
utility::string_t Alert_mission::getLevelOverride() const {
  return m_LevelOverride;
}

void Alert_mission::setLevelOverride(const utility::string_t &value) {
  m_LevelOverride = value;
  m_LevelOverrideIsSet = true;
}

bool Alert_mission::levelOverrideIsSet() const { return m_LevelOverrideIsSet; }

void Alert_mission::unsetLevelOverride() { m_LevelOverrideIsSet = false; }
std::vector<utility::string_t> &Alert_mission::getAdvancedSpawners() {
  return m_AdvancedSpawners;
}

void Alert_mission::setAdvancedSpawners(
    const std::vector<utility::string_t> &value) {
  m_AdvancedSpawners = value;
  m_AdvancedSpawnersIsSet = true;
}

bool Alert_mission::advancedSpawnersIsSet() const {
  return m_AdvancedSpawnersIsSet;
}

void Alert_mission::unsetAdvancedSpawners() { m_AdvancedSpawnersIsSet = false; }
std::vector<utility::string_t> &Alert_mission::getRequiredItems() {
  return m_RequiredItems;
}

void Alert_mission::setRequiredItems(
    const std::vector<utility::string_t> &value) {
  m_RequiredItems = value;
  m_RequiredItemsIsSet = true;
}

bool Alert_mission::requiredItemsIsSet() const { return m_RequiredItemsIsSet; }

void Alert_mission::unsetRequiredItems() { m_RequiredItemsIsSet = false; }
bool Alert_mission::isConsumeRequiredItems() const {
  return m_ConsumeRequiredItems;
}

void Alert_mission::setConsumeRequiredItems(bool value) {
  m_ConsumeRequiredItems = value;
  m_ConsumeRequiredItemsIsSet = true;
}

bool Alert_mission::consumeRequiredItemsIsSet() const {
  return m_ConsumeRequiredItemsIsSet;
}

void Alert_mission::unsetConsumeRequiredItems() {
  m_ConsumeRequiredItemsIsSet = false;
}
bool Alert_mission::isLeadersAlwaysAllowed() const {
  return m_LeadersAlwaysAllowed;
}

void Alert_mission::setLeadersAlwaysAllowed(bool value) {
  m_LeadersAlwaysAllowed = value;
  m_LeadersAlwaysAllowedIsSet = true;
}

bool Alert_mission::leadersAlwaysAllowedIsSet() const {
  return m_LeadersAlwaysAllowedIsSet;
}

void Alert_mission::unsetLeadersAlwaysAllowed() {
  m_LeadersAlwaysAllowedIsSet = false;
}
std::vector<utility::string_t> &Alert_mission::getLevelAuras() {
  return m_LevelAuras;
}

void Alert_mission::setLevelAuras(const std::vector<utility::string_t> &value) {
  m_LevelAuras = value;
  m_LevelAurasIsSet = true;
}

bool Alert_mission::levelAurasIsSet() const { return m_LevelAurasIsSet; }

void Alert_mission::unsetLevelAuras() { m_LevelAurasIsSet = false; }
utility::string_t Alert_mission::getDescription() const {
  return m_Description;
}

void Alert_mission::setDescription(const utility::string_t &value) {
  m_Description = value;
  m_DescriptionIsSet = true;
}

bool Alert_mission::descriptionIsSet() const { return m_DescriptionIsSet; }

void Alert_mission::unsetDescription() { m_DescriptionIsSet = false; }
} // namespace model
} // namespace client
} // namespace openapitools
} // namespace org
